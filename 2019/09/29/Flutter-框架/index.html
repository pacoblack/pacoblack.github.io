<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pacoblack.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Flutter 的构成,&#x2F;&#x2F;TODO: https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5c7cd2f4e51d4537b05b0974">
<meta property="og:type" content="article">
<meta property="og:title" content="Flutter 框架">
<meta property="og:url" content="https://pacoblack.github.io/2019/09/29/Flutter-%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="我爱学习">
<meta property="og:description" content="Flutter 的构成,&#x2F;&#x2F;TODO: https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5c7cd2f4e51d4537b05b0974">
<meta property="og:locale">
<meta property="og:image" content="https://pacoblack.github.io/images/Vsync_single.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/pacoblack/BlogImages/master/flutter_base/flutter1.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/pacoblack/BlogImages/master/flutter_base/flutter2.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/pacoblack/BlogImages/master/flutter_base/flutter3.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/pacoblack/BlogImages/master/flutter_base/flutter4.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/pacoblack/BlogImages/master/flutter_base/flutter5.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/pacoblack/BlogImages/master/flutter_base/flutter6.webp">
<meta property="article:published_time" content="2019-09-29T09:41:19.000Z">
<meta property="article:modified_time" content="2021-10-29T10:56:45.343Z">
<meta property="article:author" content="pacoblack">
<meta property="article:tag" content="Flutter">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pacoblack.github.io/images/Vsync_single.jpg">

<link rel="canonical" href="https://pacoblack.github.io/2019/09/29/Flutter-%E6%A1%86%E6%9E%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Flutter 框架 | 我爱学习</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">我爱学习</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这只是一场演习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="主页 fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="标签 fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="分类 fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="归档 fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="关于 fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://pacoblack.github.io/2019/09/29/Flutter-%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpeg">
      <meta itemprop="name" content="pacoblack">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我爱学习">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Flutter 框架
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-29 17:41:19" itemprop="dateCreated datePublished" datetime="2019-09-29T17:41:19+08:00">2019-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-29 18:56:45" itemprop="dateModified" datetime="2021-10-29T18:56:45+08:00">2021-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Flutter 的构成,<br>&#x2F;&#x2F;TODO: <a target="_blank" rel="noopener" href="https://juejin.im/post/5c7cd2f4e51d4537b05b0974">https://juejin.im/post/5c7cd2f4e51d4537b05b0974</a></p>
<span id="more"></span>
<h1><span id="总览">总览</span></h1><p><img src="/images/Vsync_single.jpg" alt="Vsync 流"></p>
<p>在Flutter框架中存在着一个渲染流水线（Rendering pipline）。这个渲染流水线是由垂直同步信号（Vsync）驱动的，而Vsync信号是由系统提供的，如果你的Flutter app是运行在Android上的话，那Vsync信号就是我们熟悉的Android的那个Vsync信号。当Vsync信号到来以后，Flutter 框架会按照图里的顺序执行一系列动作: 动画（Animate）、构建（Build）、布局（Layout）和绘制（Paint），最终生成一个场景（Scene）之后送往底层，由GPU绘制到屏幕上。</p>
<p>Flutter整体框架如下：<br><img src="https://raw.githubusercontent.com/pacoblack/BlogImages/master/flutter_base/flutter1.webp"></p>
<p>可见整个Flutter架构是分为两部分的。上层的框架（Framework）部分和底层的引擎（Engine）部分。</p>
<ul>
<li>框架（Framework）部分是用Dart语言写的，也是本系列文章主要涉及的部分。</li>
<li>引擎（Engine）部分是用C++实现的。引擎为框架提供支撑，也是连接框架和系统（Android&#x2F;iOS）的桥梁。</li>
</ul>
<p>触发渲染流水线的Vsync信号是来自引擎，渲染完成以后的场景也是要送入引擎来显示，并且Vsync信号的调度也是框架通过引擎来通知系统的。渲染流程从框架和引擎交互的角度用一个示意图来表示就是下面这个样子：<br><img src="https://raw.githubusercontent.com/pacoblack/BlogImages/master/flutter_base/flutter2.webp"></p>
<ol>
<li>框架通知引擎（scheduleFrame）需要调度一帧。</li>
<li>在系统的Vsync信号到来以后，引擎会首先会回调框架的_beginFrame函数。此时框架的渲染流水线进入动画（Animate）阶段，</li>
<li>在动画（Animate）阶段阶段完成以后。引擎会处理完微任务队列，接着再回调框架的_drawFrame函数。渲染流水线继续按序运行构建、布局和绘制。</li>
<li>绘制结束以后，框架调用render将绘制完成的场景送入引擎以显示到屏幕上。</li>
</ol>
<h1><span id="初始化">初始化</span></h1><p>Flutter app的入口就是函数runApp(),那么我们就从函数runApp()入手，看看这个函数被调用以后发生了什么。<br>runApp()的函数体位于 <code>widgets/binding.dart</code> 。长这样：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..attachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从调用的函数名称就可以看出来，它做了3件事，</p>
<ul>
<li>确保WidgetsFlutterBinding被初始化。</li>
<li>把你的Widget贴到什么地方去。</li>
<li>然后调度一个“热身”帧。</li>
</ul>
<h2><span id="ensureinitialized">ensureInitialized()</span></h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">      WidgetsFlutterBinding();</span><br><span class="line">    <span class="keyword">return</span> WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类继承自<code>BindingBase</code>,静态函数<code>ensureInitialized()</code>所做的就是返回一个<code>WidgetsBinding.instance</code>单例。<br>关于抽象类BindingBase需要注意两点</p>
<ul>
<li>一个是在其构造的时候会调用函数initInstances()。</li>
<li>另一个就是BindingBase有一个getter，返回的是window。</li>
</ul>
<p>我们挨个看一下这几个绑定类在调用initInstances()的时候做了什么的吧。</p>
<h3><span id="gesturebinding-手势绑定">GestureBinding 手势绑定</span></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> GestureBinding <span class="keyword">on</span> BindingBase <span class="keyword">implements</span> HitTestable, HitTestDispatcher, HitTestTarget &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">window</span>.onPointerDataPacket = _handlePointerDataPacket;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在调用initInstances()的时候，主要做的事情就是给window设置了一个手势处理的回调函数。所以这个绑定主要是负责管理手势事件的。</p>
<h3><span id="servicesbinding-服务绑定">ServicesBinding 服务绑定</span></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> ServicesBinding <span class="keyword">on</span> BindingBase &#123;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">   <span class="keyword">super</span>.initInstances();</span><br><span class="line">   _instance = <span class="keyword">this</span>;</span><br><span class="line">   <span class="built_in">window</span></span><br><span class="line">     ..onPlatformMessage = BinaryMessages.handlePlatformMessage;</span><br><span class="line">   initLicenses();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这个绑定主要是给window设置了处理Platform Message的回调。</p>
<h3><span id="schedulerbinding-调度绑定">SchedulerBinding 调度绑定</span></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> SchedulerBinding <span class="keyword">on</span> BindingBase, ServicesBinding &#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initInstances();</span><br><span class="line">  _instance = <span class="keyword">this</span>;</span><br><span class="line">  <span class="built_in">window</span>.onBeginFrame = _handleBeginFrame;</span><br><span class="line">  <span class="built_in">window</span>.onDrawFrame = _handleDrawFrame;</span><br><span class="line">  SystemChannels.lifecycle.setMessageHandler(_handleLifecycleMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个绑定主要是给window设置了onBeginFrame和onDrawFrame的回调，回忆之前讲渲染流水线的时候，当Vsync信号到来的时候engine会回调Flutter的来启动渲染流程，这两个回调就是在SchedulerBinding管理的。</p>
<h3><span id="paintingbinding-绘制绑定">PaintingBinding 绘制绑定</span></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> PaintingBinding <span class="keyword">on</span> BindingBase, ServicesBinding &#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initInstances();</span><br><span class="line">  _instance = <span class="keyword">this</span>;</span><br><span class="line">  _imageCache = createImageCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个绑定只是创建了个图片缓存。</p>
<h3><span id="semanticsbinding-辅助功能绑定">SemanticsBinding 辅助功能绑定</span></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> SemanticsBinding <span class="keyword">on</span> BindingBase &#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initInstances();</span><br><span class="line">  _instance = <span class="keyword">this</span>;</span><br><span class="line">  _accessibilityFeatures = <span class="built_in">window</span>.accessibilityFeatures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个绑定管理辅助功能。</p>
<h3><span id="rendererbinding渲染绑定比较重要">RendererBinding渲染绑定(比较重要)</span></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> RendererBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">   <span class="keyword">super</span>.initInstances();</span><br><span class="line">   _instance = <span class="keyword">this</span>;</span><br><span class="line">   _pipelineOwner = PipelineOwner(</span><br><span class="line">     onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">     onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">     onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">   );</span><br><span class="line">   <span class="built_in">window</span></span><br><span class="line">     ..onMetricsChanged = handleMetricsChanged</span><br><span class="line">     ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class="line">     ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class="line">     ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class="line">     ..onSemanticsAction = _handleSemanticsAction;</span><br><span class="line">   initRenderView();</span><br><span class="line">   _handleSemanticsEnabledChanged();</span><br><span class="line">   <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">   addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">   _mouseTracker = _createMouseTracker();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这个绑定是负责管理渲染流程的，初始化的时候做的事情也比较多。</p>
<ul>
<li><p>首先是实例化了一个PipelineOwner类。这个类负责管理驱动我们之前说的渲染流水线。</p>
</li>
<li><p>随后给window设置了一系列回调函数，处理屏幕尺寸变化，亮度变化等。</p>
</li>
<li><p>接着调用initRenderView()。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span> initRenderView() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(renderView == <span class="keyword">null</span>);</span><br><span class="line">  renderView = RenderView(configuration: createViewConfiguration(), <span class="built_in">window</span>: <span class="built_in">window</span>);</span><br><span class="line">  renderView.scheduleInitialFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个函数实例化了一个RenderView类。RenderView继承自RenderObject。我们都知道Flutter框架中存在这一个渲染树（render tree）。这个RenderView就是渲染树（render tree）的根节点，这一点可以通过打开”Flutter Inspector”看到，在”Render Tree”这个Tab下，最根部的红框里就是这个RenderView。</p>
</blockquote>
</li>
<li><p>最后调用addPersistentFrameCallback添加了一个回调函数。请大家记住这个回调，渲染流水线的主要阶段都会在这个回调里启动。</p>
</li>
</ul>
<h3><span id="widgetsbinding-组件绑定">WidgetsBinding 组件绑定</span></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> WidgetsBinding <span class="keyword">on</span> BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    buildOwner.onBuildScheduled = _handleBuildScheduled;</span><br><span class="line">    <span class="built_in">window</span>.onLocaleChanged = handleLocaleChanged;</span><br><span class="line">    <span class="built_in">window</span>.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;</span><br><span class="line">    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);</span><br><span class="line">    SystemChannels.system.setMessageHandler(_handleSystemMessage);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个绑定的初始化先给buildOwner设置了个onBuildScheduled回调，还记得渲染绑定里初始化的时候实例化了一个PipelineOwner吗？这个BuildOwner是在组件绑定里实例化的。它主要负责管理Widget的重建，记住这两个”owner”。他们将会Flutter框架里的核心类。<br>接着给window设置了两个回调，因为和渲染关系不大，就不细说了。<br>最后设置SystemChannels.navigation和SystemChannels.system的消息处理函数。这两个回调一个是专门处理路由的，另一个是处理一些系统事件，比如剪贴板，震动反馈，系统音效等等。</p>
<h2><span id="attachrootwidgetapp">attachRootWidget(app)</span></h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">  _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">    container: renderView,</span><br><span class="line">    debugShortDescription: <span class="string">&#x27;[root]&#x27;</span>,</span><br><span class="line">    child: rootWidget</span><br><span class="line">  ).attachToRenderTree(buildOwner, renderViewElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前说的RendererBinding的初始化的时候，我们得到了一个RenderView的实例，render tree的根节点。<br>RenderView是继承自RenderObject的，而RenderObject需要有对应的Widget和Element。<br>上述代码中的RenderObjectToWidgetAdapter就是这个Widget。而对应的Element就是RenderObjectToWidgetElement了，既然是要关联到render tree的根节点，那它自然也就是element tree的根节点了。<br>从上述分析我们可以得出结论：</p>
<ul>
<li>渲染绑定（RendererBinding）通过pipelineOwner间接持有render tree的根节点RenderView。</li>
<li>组件绑定（WidgetsBinding）持有element tree的根节点RenderObjectToWidgetElement。</li>
</ul>
<p>那么RenderObjectToWidgetElement是怎么和RenderView关联起来的呢，那自然是通过一个Widget做到的了，看下RenderObjectToWidgetAdapter的代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectToWidgetAdapter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObject</span>&gt; <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a bridge from a [RenderObject] to an [Element] tree.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Used by [WidgetsBinding] to attach the root widget to the [RenderView].</span></span></span><br><span class="line">  RenderObjectToWidgetAdapter(&#123;</span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="keyword">this</span>.container,</span><br><span class="line">    <span class="keyword">this</span>.debugShortDescription</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: GlobalObjectKey(container));</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObjectToWidgetElement&lt;T&gt; createElement() =&gt; RenderObjectToWidgetElement&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObjectWithChildMixin&lt;T&gt; createRenderObject(BuildContext context) =&gt; container;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>你看，createElement()返回的就是RenderObjectToWidgetElement，而createRenderObject返回的container就是构造这个Widget传入的RenderView了。而我们自己的MyApp作为一个子widget存在于RenderObjectToWidgetAdapter之中。<br>最后调用的attachToRenderTree做的事情属于我们之前说的渲染流水线的构建（Build）阶段，这时会根据我们自己的widget生成element tree和render tree。构建（Build）阶段完成以后，那自然是要进入布局（Layout）阶段和绘制（Paint）阶段了。怎么进呢？那就是runApp里的最后一个函数调用了。</p>
<h2><span id="schedulewarmupframe">scheduleWarmUpFrame()</span></h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleWarmUpFrame() &#123;</span><br><span class="line">  ...</span><br><span class="line">  Timer.run(() &#123;</span><br><span class="line">    ...</span><br><span class="line">    handleBeginFrame(<span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">  Timer.run(() &#123;</span><br><span class="line">    ...</span><br><span class="line">    handleDrawFrame();</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数其实就调了两个函数，就是之前我们讲window的时候说的两个回调函数onBeginFrame和onDrawFrame吗？这里其实就是在具体执行这两个回调。最后渲染出来首帧场景送入engine显示到屏幕。这里使用Timer.run()来异步运行两个回调，是为了在它们被调用之前有机会处理完微任务队列（microtask queue）。</p>
<p>总结起来的要点这么几个：</p>
<ul>
<li>3个重要绑定：SchedulerBinding，RendererBinding和WidgetsBinding。</li>
<li>2个“owner”：PipelineOwner和BuildOwner。</li>
<li>2颗树的根节点：render tree根节点RenderView；element tree根节点RenderObjectToWidgetElement。</li>
</ul>
<h1><span id="绘制组件">绘制组件</span></h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyWidget());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _message = <span class="string">&quot;Flutter框架分析&quot;</span>;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; ErrorWidget(_message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以这个最简单的demo为例，来分析整个的绘制过程<br>首先用Flutter Inspector查看:<br><img src="https://raw.githubusercontent.com/pacoblack/BlogImages/master/flutter_base/flutter3.webp"><br>从上图可见就三个层级 <code>root</code> -&gt; <code>MyWidget</code> -&gt; <code>ErrorWidget</code>。这里的root就是上面提到的 <code>RenderObjectToWidgetAdapter</code>.<br>Element Tree其实是 <code>RenderObjectToWidgetElement</code> -&gt; <code>StatelessElement</code> -&gt; <code>LeafRenderObjectElement</code>,其中 RenderObjectToWidgetElement是element tree的根节点， 这个根节点是持有render tree的根节点<code>RenderView</code>的。它的子节点就是我们自己写的MyWidget对应的 <code>StatelessElement</code>。而这个element是不持有<code>RenderObject</code>的。只有最下面的ErrorWidget对应的<code>LeafRenderObjectElement</code>才持有第二个RenderObject。所以 render tree是只有两层的: <code>RenderView</code> -&gt; <code>RenderErrorBox</code> 。<br><img src="https://raw.githubusercontent.com/pacoblack/BlogImages/master/flutter_base/flutter4.webp"><br>图中绿色连接线表示的是element tree的层级关系。黄色的连接线表示render tree的层级关系。</p>
<p>从上面这个例子可以看出来，Widget是用来描述对应的Element的描述或配置。Element都是从Widget中生成的。每个Widget都会对应一个Element。但是并非每个Widget&#x2F;Element会对应一个RenderObject。只有这个Widget继承自RenderObjectWidget的时候才会有对应的RenderObject。</p>
<ul>
<li>Widget是对Element的配置或描述。Flutter app开发者主要的工作都是在和Widget打交道。我们不需要关心树的维护更新，只需要专注于对Widget状态的维护就可以了，大大减轻了开发者的负担。</li>
<li>Element负责维护element tree。Element不会去管具体的颜色，字体大小，显示内容等等这些UI的配置或描述，也不会去管布局，绘制这些事，它只管自己的那棵树。Element的主要工作都处于渲染流水线的构建（build）阶段。</li>
<li>RenderObject负责具体布局，绘制这些事情。也就是渲染流水线的布局（layout）和 绘制（paint）阶段。</li>
</ul>
<h2><span id="widget">Widget</span></h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Widget(&#123; <span class="keyword">this</span>.key &#125;);</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="built_in">Element</span> createElement();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法createElement()负责实例化对应的Element.</p>
<h3><span id="statelesswidget">StatelessWidget</span></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Initializes [key] for subclasses.</span></span></span><br><span class="line">  <span class="keyword">const</span> StatelessWidget(&#123; Key key &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatelessElement createElement() =&gt; StatelessElement(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StatelessWidget对Flutter开发者来讲再熟悉不过了。它的createElement方法返回的是一个StatelessElement实例。<br>StatelessWidget没有生成RenderObject的方法。所以StatelessWidget只是个中间层，它需要实现build方法来返回子Widget。</p>
<h3><span id="statefulwidget">StatefulWidget</span></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatefulElement createElement() =&gt; StatefulElement(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  State createState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StatefulWidget对Flutter开发者来讲非常熟悉了。createElement方法返回的是一个StatefulElement实例。方法createState()构建对应于这个StatefulWidget的State。<br>StatefulWidget没有生成RenderObject的方法。所以StatefulWidget也只是个中间层，它需要对应的State实现build方法来返回子Widget。</p>
<h3><span id="state">State</span></h3><p>说到StatefulWidget就不能不说说State。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span>&gt; <span class="keyword">extends</span> <span class="title">Diagnosticable</span> </span>&#123;</span><br><span class="line">  T <span class="keyword">get</span> widget =&gt; _widget;</span><br><span class="line">  T _widget;</span><br><span class="line"></span><br><span class="line">  BuildContext <span class="keyword">get</span> context =&gt; _element;</span><br><span class="line">  StatefulElement _element;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来判断这个State是不是关联到element tree中的某个Element。如果当前State不是在mounted == true的状态，你去调用setState()是会crash的。</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> mounted =&gt; _element != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> initState() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(<span class="keyword">covariant</span> T oldWidget) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> result = fn() <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span><br><span class="line">    _element.markNeedsBuild();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> deactivate() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的context 返回的其实是上面 get 的Element</span></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="inheritedwidget">InheritedWidget</span></h3><p>InheritedWidget既不是StatefullWidget也不是StatelessWidget。它是用来向下传递数据的。在InheritedWidget之下的子节点都可以通过调用 BuildContext.inheritFromWidgetOfExactType() 来获取这个 InheritedWidget。它的createElement()函数返回的是一个InheritedElement。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritedWidget</span> <span class="keyword">extends</span> <span class="title">ProxyWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> InheritedWidget(&#123; Key key, Widget child &#125;)</span><br><span class="line">    : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  InheritedElement createElement() =&gt; InheritedElement(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(<span class="keyword">covariant</span> InheritedWidget oldWidget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="renderobjectwidget">RenderObjectWidget</span></h3><p>RenderObjectWidget用来配置RenderObject。其createElement()函数返回RenderObjectElement。由其子类实现。相对于上面说的其他Widget。这里多了一个createRenderObject()方法。用来实例化RenderObject。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> RenderObjectWidget(&#123; Key key &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObjectElement createElement();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  RenderObject createRenderObject(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, <span class="keyword">covariant</span> RenderObject renderObject) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> didUnmountRenderObject(<span class="keyword">covariant</span> RenderObject renderObject) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RenderObjectWidget只是个配置，当配置发生变化需要应用到现有的RenderObject上的时候，Flutter框架会调用updateRenderObject()来把新的配置设置给相应的RenderObject。<br>RenderObjectWidget有三个比较重要的子类：</p>
<ul>
<li>LeafRenderObjectWidget这个Widget 配置的节点处于树的最底层，它是没有孩子的。对应 LeafRenderObjectElement。</li>
<li>SingleChildRenderObjectWidget， 只含有一个孩子。对应 SingleChildRenderObjectElement。</li>
<li>MultiChildRenderObjectWidget， 有多个孩子。对应 MultiChildRenderObjectElement。</li>
</ul>
<h2><span id="element">Element</span></h2><p>Element构成了element tree。这个类主要在做的事情就是维护这棵树。<br>从上面对Widget的分析我们可以看出，好像每个特别的Widget都会有一个对应的Element。特别是对于RenderObjectWidget。如果我有一个XXXRenderObjectWidget，它的createElement()通常会返回一个XXXRenderObjectElement。为简单起见。我们的分析就仅限于比较基础的一些Element。<br>首先来看一下基类Element。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> <span class="keyword">implements</span> <span class="title">BuildContext</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Element</span> _parent;</span><br><span class="line">    Widget _widget;</span><br><span class="line">    BuildOwner _owner;</span><br><span class="line">    <span class="built_in">dynamic</span> _slot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> visitChildren(ElementVisitor visitor) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Element</span> updateChild(<span class="built_in">Element</span> child, Widget newWidget, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> unmount() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> update(<span class="keyword">covariant</span> Widget newWidget) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@protected</span></span><br><span class="line">    <span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</span><br><span class="line">      newChild.mount(<span class="keyword">this</span>, newSlot);</span><br><span class="line">      <span class="keyword">return</span> newChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      _dirty = <span class="keyword">true</span>;</span><br><span class="line">      owner.scheduleBuildFor(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">      <span class="keyword">if</span> (!_active || !_dirty)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      performRebuild();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@protected</span></span><br><span class="line">    <span class="keyword">void</span> performRebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Element持有当前的Widget，还有BuildOwner。这个BuildOwner是之前在WidgetsBinding里实例化的。<br>Element是树结构，它会持有父节点_parent。_slot由父Element设置，目的是告诉当前Element在父节点的什么位置。由于Element基类不知道子类会如何管理孩子节点。所以函数visitChildren()由子类实现以遍历孩子节点。<br>函数updateChild()比较重要，用来更新一个孩子节点。更新有四种情况：</p>
<ul>
<li>新Widget为空，老Widget也为空。则啥也不做。</li>
<li>新Widget为空，老Widget不为空。这个Element被移除。</li>
<li>新Widget不为空，老Widget为空。则调用inflateWidget()以这个Wiget为配置实例化一个Element。</li>
<li>新Widget不为空，老Widget不为空。调用update()函数更新子Element。update()函数由子类实现。</li>
</ul>
<p>新Element被实例化以后会调用<code>mount()</code>来把自己加入element tree。要移除的时候会调用unmount()。</p>
<p>函数<code>markNeedsBuild()</code>用来标记Element为“脏”(dirty)状态。表明渲染下一帧的时候这个Element需要被重建。</p>
<p>函数<code>rebuild()</code>在渲染流水线的构建（build）阶段被调用。具体的重建在函数performRebuild()中，由Element子类实现。<br>Widget有一些比较重要的子类，对应的Element也有一些比较重要的子类。</p>
<h3><span id="componentelement">ComponentElement</span></h3><p>ComponentElement表示当前这个Element是用来组合其他Element的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  ComponentElement(Widget widget) : <span class="keyword">super</span>(widget);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Element</span> _child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    Widget built;</span><br><span class="line">    built = build();</span><br><span class="line">    _child = updateChild(_child, built, slot);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ComponentElement继承自Element。是个抽象类。_child是其孩子。在函数performRebuild()中会调用build()来实例化一个Widget。build()函数由其子类实现。</p>
<h3><span id="statelesselement">StatelessElement</span></h3><p>StatelessElement对应的Widget是我们熟悉的StatelessWidget。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatelessElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build() =&gt; widget.build(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> update(StatelessWidget newWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    rebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>build()函数直接调用的就是StatelessWidget.build()。现在你知道你写在StatelessWidget里的build()是在哪里被调用的了吧。而且你看，build()函数的入参是this。我们都知道这个函数的入参应该是BuildContext类型的。这个入参其实就是这个StatelessElement。</p>
<h3><span id="statefulelement">StatefulElement</span></h3><p>StatefulElement对应的Widget是我们熟悉的StatefulWidget。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates an element that uses the given widget as its configuration.</span></span></span><br><span class="line">  StatefulElement(StatefulWidget widget)</span><br><span class="line">      : _state = widget.createState(),</span><br><span class="line">        <span class="keyword">super</span>(widget) &#123;</span><br><span class="line">    _state._element = <span class="keyword">this</span>;</span><br><span class="line">    _state._widget = widget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build() =&gt; state.build(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> _firstBuild() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> debugCheckForReturnedFuture = _state.initState()</span><br><span class="line">    _state.didChangeDependencies();</span><br><span class="line">    <span class="keyword">super</span>._firstBuild();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> deactivate() &#123;</span><br><span class="line">    _state.deactivate();</span><br><span class="line">    <span class="keyword">super</span>.deactivate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> unmount() &#123;</span><br><span class="line">    <span class="keyword">super</span>.unmount();</span><br><span class="line">    _state.dispose();</span><br><span class="line">    _state._element = <span class="keyword">null</span>;</span><br><span class="line">    _state = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">    _state.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在StatefulElement构造的时候会调用对应StatefulWidget的createState()函数。也就是说State是在实例化StatefulElement的时候被实例化的。并且State实例会被这个StatefulElement实例持有。从这里也可以看出为什么StatefulWidget的状态要由单独的State管理，每次刷新的时候可能会有一个新的StatefulWidget被创建，但是State实例是不变的。<br>build()函数调用的是我们熟悉的State.build(this)，现在你也知道了State的build()函数是在哪里被调用的了吧。而且你看，build()函数的入参是this。我们都知道这个函数的入参应该是BuildContext类型的。这个入参其实就是这个StatefulElement。<br>我们都知道State有状态，当状态改变时对应的回调函数会被调用。这些回调函数其实都是在StatefulElement里被调用的。<br>在函数_firstBuild()里会调用State.initState()和State.didChangeDependencies()。<br>在函数deactivate()里会调用State.deactivate()。<br>在函数unmount()里会调用State.dispose()。<br>在函数didChangeDependencies()里会调用State.didChangeDependencies()。</p>
<h3><span id="inheritedelement">InheritedElement</span></h3><p>InheritedElement对应的Widget是InheritedWidget。其内部实现主要是在维护对其有依赖的子Element的Map，以及在需要的时候调用子Element对应的didChangeDependencies()回调，这里就不贴代码了，大家感兴趣的话可以自己去看一下源码。</p>
<h3><span id="renderobjectelement">RenderObjectElement</span></h3><p>RenderObjectElement对应的Widget是RenderObjectWidget。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  RenderObject _renderObject;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">    attachRenderObject(newSlot);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> unmount() &#123;</span><br><span class="line">    <span class="keyword">super</span>.unmount();</span><br><span class="line">    widget.didUnmountRenderObject(renderObject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> update(<span class="keyword">covariant</span> RenderObjectWidget newWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> insertChildRenderObject(<span class="keyword">covariant</span> RenderObject child, <span class="keyword">covariant</span> <span class="built_in">dynamic</span> slot);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> moveChildRenderObject(<span class="keyword">covariant</span> RenderObject child, <span class="keyword">covariant</span> <span class="built_in">dynamic</span> slot);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> removeChildRenderObject(<span class="keyword">covariant</span> RenderObject child);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数mount()被调用的时候会调用RenderObjectWidget.createRenderObject()来实例化RenderObject。<br>函数update()和performRebuild()被调用的时候会调用RenderObjectWidget.updateRenderObject()。<br>函数unmount()被调用的时候会调用RenderObjectWidget.didUnmountRenderObject()。</p>
<h2><span id="renderobject">RenderObject</span></h2><p>RenderObject负责渲染流水线布局（layout）阶段和绘制（paint）阶段的工作。同时也维护render tree。对render tree的维护方法是来自基类AbstractNode。这里我们主要关注和渲染流水线相关的一些方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> <span class="keyword">extends</span> <span class="title">AbstractNode</span> <span class="title">with</span> <span class="title">DiagnosticableTreeMixin</span> <span class="keyword">implements</span> <span class="title">HitTestTarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> markNeedsLayout() &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">if</span> (sizedByParent) &#123;</span><br><span class="line">        performResize();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    performLayout();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> performResize();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> performLayout();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>markNeedsLayout()标记这个RenderObject需要重新做布局。markNeedsPaint标记这个RenderObject需要重绘。这两个函数只做标记。标记之后Flutter框架会调度一帧，在下一个Vsync信号到来之后才真正做布局和绘制。<br>真正的布局在函数layout()中进行。这个函数会做一次判断，如果sizedByParent为true。则会调用performResize()。表明这个RenderObject的尺寸仅由其父节点决定。然后会调用performLayout()做布局。performResize()和performLayout()都需要RenderObject的子类去实现。</p>
<h1><span id="flutter运行框架">flutter运行框架</span></h1><p>Flutter的渲染流水线，这个过程大致可以分为两段操作。第一段是从State.setState()到去engine那里请求一帧，第二段就是Vsync信号到来以后渲染流水线开始重建新的一帧最后送入engine去显示。</p>
<h2><span id="statesetstate">State.setState()</span></h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> result = fn() <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span><br><span class="line"></span><br><span class="line">    _element.markNeedsBuild();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里会调用到Element的markNeedsBuild()函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (dirty)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    owner.scheduleBuildFor(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Element首先看自己是不是active的状态，不是的话就直接返回了，如果是“脏”（dirty）的状态也直接返回，不是的话会置上这个状态然后调用BuildOwner的scheduleBuildFor()函数，这个BuildOwner我们之前介绍过，它的实例是在WidgetsBinding初始化的时候构建的。每个Element的都会持有BuildOwner的引用。由其父Element在mount的时候设置。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleBuildFor(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">  <span class="keyword">if</span> (element._inDirtyList) &#123;</span><br><span class="line">    _dirtyElementsNeedsResorting = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!_scheduledFlushDirtyElements &amp;&amp; onBuildScheduled != <span class="keyword">null</span>) &#123;</span><br><span class="line">    _scheduledFlushDirtyElements = <span class="keyword">true</span>;</span><br><span class="line">    onBuildScheduled();</span><br><span class="line">  &#125;</span><br><span class="line">  _dirtyElements.add(element);</span><br><span class="line">  element._inDirtyList = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BuildOwner会维护一个_dirtyElements列表，所有被标记为“脏”（dirty）的element都会被添加进去。<br>在此之前会调用onBuildScheduled()。这个函数是WidgetsBinding初始化的时候设置给BuildOwner的，对应的是WidgetsBinding._handleBuildScheduled()。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _handleBuildScheduled() &#123;</span><br><span class="line">    ensureVisualUpdate();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里会调用到ensureVisualUpdate()。这个函数定义在SchedulerBinding里的</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ensureVisualUpdate() &#123;</span><br><span class="line">    <span class="keyword">switch</span> (schedulerPhase) &#123;</span><br><span class="line">      <span class="keyword">case</span> SchedulerPhase.idle:</span><br><span class="line">      <span class="keyword">case</span> SchedulerPhase.postFrameCallbacks:</span><br><span class="line">        scheduleFrame();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> SchedulerPhase.transientCallbacks:</span><br><span class="line">      <span class="keyword">case</span> SchedulerPhase.midFrameMicrotasks:</span><br><span class="line">      <span class="keyword">case</span> SchedulerPhase.persistentCallbacks:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>函数ensureVisualUpdate()会判断当前调度所处的状态，如果是在idle（空闲）或者postFrameCallbacks运行状态则调用scheduleFrame()。其他状态则直接返回。下面这三个状态正是渲染流水线运行的时候。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleFrame() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_hasScheduledFrame || !_framesEnabled)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">window</span>.scheduleFrame();</span><br><span class="line">    _hasScheduledFrame = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在函数scheduleFrame()里我们看到了熟悉的window。<br>这里就是通知engine去调度一帧的地方了。调度之后会置上_hasScheduledFrame标志位，避免重复请求。另外一个标志位_framesEnabled是代表当前app的状态，或者说其所处的生命周期是否允许刷新界面。这个状态有四种：resumed，inactive，paused和suspending。</p>
<ul>
<li>resumed：app可见且可以响应用户输入。</li>
<li>inactive：app不能响应用户输入，例如在Android上弹出系统对话框。</li>
<li>paused：app对用户不可见。</li>
<li>suspending：app挂起？？这个状态貌似Android和iOS都没有上报。</li>
</ul>
<p>_framesEnabled只有在resumed和inactive状态下才为true。也就是说，只有在这两个状态下Flutter框架才会刷新页面。</p>
<p>第一阶段的主要工作就是把需要重建的Element放入_dirtyElements列表。<br>接下来Flutter框架会等待Vsync信号到来以后engine回调框架，这就是第二段要做的事情了。</p>
<h2><span id="vsync信号接收">Vsync信号接收</span></h2><p>Vsync信号到来之后，engin会按顺序回调window的两个回调函数：onBeginFrame()和onDrawFrame()。<br>这两个回调是SchedulerBinding初始化的时候设置给window的。对应的是SchedulerBinding.handleBeginFrame()和SchedulerBinding.handleDrawFrame()。</p>
<h3><span id="onbeginframe">onBeginFrame</span></h3><p>这个回调会直接走到SchedulerBinding.handleBeginFrame()。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> handleBeginFrame(<span class="built_in">Duration</span> rawTimeStamp) &#123;</span><br><span class="line"> ...</span><br><span class="line">  _hasScheduledFrame = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// TRANSIENT FRAME CALLBACKS</span></span><br><span class="line">    _schedulerPhase = SchedulerPhase.transientCallbacks;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, _FrameCallbackEntry&gt; callbacks = _transientCallbacks;</span><br><span class="line">    _transientCallbacks = &lt;<span class="built_in">int</span>, _FrameCallbackEntry&gt;&#123;&#125;;</span><br><span class="line">    callbacks.forEach((<span class="built_in">int</span> id, _FrameCallbackEntry callbackEntry) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!_removedIds.contains(id))</span><br><span class="line">        _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack);</span><br><span class="line">    &#125;);</span><br><span class="line">    _removedIds.clear();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    _schedulerPhase = SchedulerPhase.midFrameMicrotasks;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要是在依次回调“Transient”回调函数，这些回调函数是在调度之前设置在SchedulerBinding里的，这里的“Transient”意思是临时的，或者说是一次性的。原因是这些回调函数只会被调用一次。<br>注意看代码里_transientCallbacks被置为空Map了。如果想在下一帧再次调用的话需要提前重新设置回调。这些回调主要和动画有关系。也就是渲染流水线里的第一阶段，动画（Animate）阶段。<br>在运行回调之前_schedulerPhase的状态被设置为SchedulerPhase.transientCallbacks。回调处理完以后状态更新至SchedulerPhase.midFrameMicrotasks意思是接下来会处理微任务队列。处理完微任务以后，engine会接着回调onDrawFrame()。</p>
<h3><span id="ondrawframe">onDrawFrame</span></h3><p>这个回调会直接走到SchedulerBinding.handleDrawFrame()。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> handleDrawFrame() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// PERSISTENT FRAME CALLBACKS</span></span><br><span class="line">      _schedulerPhase = SchedulerPhase.persistentCallbacks;</span><br><span class="line">      <span class="keyword">for</span> (FrameCallback callback <span class="keyword">in</span> _persistentCallbacks)</span><br><span class="line">        _invokeFrameCallback(callback, _currentFrameTimeStamp);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// POST-FRAME CALLBACKS</span></span><br><span class="line">      _schedulerPhase = SchedulerPhase.postFrameCallbacks;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;FrameCallback&gt; localPostFrameCallbacks =</span><br><span class="line">          <span class="built_in">List</span>&lt;FrameCallback&gt;.from(_postFrameCallbacks);</span><br><span class="line">      _postFrameCallbacks.clear();</span><br><span class="line">      <span class="keyword">for</span> (FrameCallback callback <span class="keyword">in</span> localPostFrameCallbacks)</span><br><span class="line">        _invokeFrameCallback(callback, _currentFrameTimeStamp);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _schedulerPhase = SchedulerPhase.idle;</span><br><span class="line">      _currentFrameTimeStamp = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在handleDrawFrame里按顺序处理了两类回调，一类叫“Persistent”回调，另一类叫“Post-Frame”回调。<br>“Persistent”字面意思是永久的。这类回调一旦注册以后是不能取消的。主要用来驱动渲染流水线。渲染流水线的构建（build），布局（layout）和绘制（paint）阶段都是在其中一个回调里的。<br>“Post-Frame”回调主要是在新帧渲染完成以后的一类调用，此类回调只会被调用一次。<br>在运行“Persistent”回调之前_schedulerPhase状态变为SchedulerPhase.persistentCallbacks。在运行“Post-Frame”回调之前_schedulerPhase状态变为SchedulerPhase.postFrameCallbacks。最终状态变为SchedulerPhase.idle。<br>这里我们主要关注一个“Persistent”回调：WidgetsBinding.drawFrame()。这个函数是在RendererBinding初始化的时候加入到“Persistent”回调的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (renderViewElement != <span class="keyword">null</span>)</span><br><span class="line">      buildOwner.buildScope(renderViewElement);</span><br><span class="line">    <span class="keyword">super</span>.drawFrame();</span><br><span class="line">    buildOwner.finalizeTree();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先会调用buildOwner.buildScope(renderViewElement)。其入参renderViewElement是element tree的根节点。此时渲染流水线就进入了构建（build）阶段。接下来调用了super.drawFrame()。这个函数定义在RendererBinding中。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">  pipelineOwner.flushLayout();</span><br><span class="line">  pipelineOwner.flushCompositingBits();</span><br><span class="line">  pipelineOwner.flushPaint();</span><br><span class="line">  renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">  pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出渲染流水线的接力棒传到了pipelineOwner的手里，渲染流水线就进入了布局（layout）阶段和绘制（paint）阶段。<br>关于最后这两个阶段本篇不做详细介绍。这里大家只要知道绘制完成以后Flutter框架最终会调用window.render(scene)将新帧的数据送入engine显示到屏幕。<br>最后调用buildOwner.finalizeTree()。这个函数的作用是清理不再需要的Element节点。在element tree更新以后可能有些节点就不再需要挂载在树上了，在finalizeTree()的时候会将这些节点及其子节点unmount。</p>
<h3><span id="build-构建阶段">build 构建阶段</span></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [VoidCallback callback]) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _scheduledFlushDirtyElements = <span class="keyword">true</span>;</span><br><span class="line">      _dirtyElements.sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">      _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">      <span class="built_in">int</span> dirtyCount = _dirtyElements.length;</span><br><span class="line">      <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (index &lt; dirtyCount) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          _dirtyElements[index].rebuild();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">Element</span> element <span class="keyword">in</span> _dirtyElements) &#123;</span><br><span class="line">        element._inDirtyList = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _dirtyElements.clear();</span><br><span class="line">      _scheduledFlushDirtyElements = <span class="keyword">false</span>;</span><br><span class="line">      _dirtyElementsNeedsResorting = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>还记得在调度帧之前会把需要更新的Element标记为“脏”（dirty）并放入BuildOwner的_dirtyElements列表。这里Flutter会先按照深度给这个列表排个序。因为Element在重建的时候其子节点也都会重建，这样如果父节点和子节点都为“脏”的话，先重建父节点就避免了子节点的重复重建。</p>
<p>排完序就是遍历_dirtyElements列表。依次调用Element.rebuild()。这个函数又会调用到Element.performRebuild()。我们之前介绍Element的时候说过performRebuild()由其子类实现。</p>
<p>我们之前的出发点是State.setState()。那就先看看StatefulElement如何做的。它的performRebuild()是在其父类ComponentElement里：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    Widget built;</span><br><span class="line">    built = build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _child = updateChild(_child, built, slot);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>回忆一下ComponentElement。这个build()函数最终会调用到State.build()了。返回的就是我们自己实例化的Widget。拿到这个新Widget就去调用updateChild()。之前在讲Element的时候我们介绍过updateChild()这个函数。由增，删，改这么几种情况，对于MyWidget，从State.setState()过来是属于改的情况。此时会调用child.update(newWidget)。这个update()函数又是由各个Element子类实现的。这里我们只列举几个比较典型的。<br>StatefulElement和StatelessElement的update()函数最终都会调用基类Element的rebuild()函数。好像在兜圈圈的感觉。。。<br>RenderObjectElement的update()函数就比较简单了</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(<span class="keyword">covariant</span> RenderObjectWidget newWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>更新只是调用了一下RenderObjectWidget.updateRenderObject()。这个函数我们之前介绍过，只是把新的配置设置到现有的RenderObject上。<br>回到上面那个兜圈圈的问题。理清这里的调用关系的关键就是要搞清楚是此时的Element是在对自己进行操作还是对孩子进行操作。假设我们有这样的一个三层element tree进行更新重建。</p>
<ul>
<li><p>父(StatefulElement)</p>
</li>
<li><p>子(StatefulElement)</p>
</li>
<li><p>孙(LeafRenderObjectElement)</p>
</li>
</ul>
<p>那么从父节点开始，调用顺序如下：<br>父.rebuild()—&gt;父.performRebuild()—&gt;父.updateChild()—&gt;子.update()—&gt;子.rebuild()—&gt;子.performRebuild()—&gt;子.updateChild()—&gt;孙.update()</p>
<p>至此渲染流水线的构建（build）阶段就跑完了。接下来就由pipelineOwner驱动开始布局（layout）和绘制（paint）阶段了。</p>
<h1><span id="动画">动画</span></h1><p>&#x2F;&#x2F;TODO</p>
<h1><span id="layout-布局">Layout 布局</span></h1><p>Flutter框架的布局采用的是盒子约束（Box constraints）模型。其布局流程如下图所示：<br><img src="https://raw.githubusercontent.com/pacoblack/BlogImages/master/flutter_base/flutter5.webp"><br>图中的树是render tree。每个节点都是一个RenderObject。从根节点开始，每个父节点启动子节点的布局流程，在启动的时候会传入Constraits，也即“约束”。Flutter使用最多的是盒子约束（Box constraints）。盒子约束包含4个域：最大宽度（maxWidth）最小宽度（minWidth）最大高度（maxHeight）和最小高度（minHeight）。子节点布局完成以后会确定自己的尺寸（size）。size包含两个域：宽度（width）和高度（height）。父节点在子节点布局完成以后需要的时候可以获取子节点的尺寸（size）整体的布局流程可以描述为一下一上，一下就是约束从上往下传递，一上是指尺寸从下往上传递。这样Flutter的布局流程只需要一趟遍历render tree即可完成。具体布局过程是如何运行的，我们通过分析源码来进一步分析一下。<br>在之前的分析中，我们知道在drawFrame 中，我们会走到 RenderBinding中</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">  pipelineOwner.flushLayout();</span><br><span class="line">  pipelineOwner.flushCompositingBits();</span><br><span class="line">  pipelineOwner.flushPaint();</span><br><span class="line">  renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">  pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 pipelineOwner.flushLayout()便是布局阶段</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushLayout() &#123;</span><br><span class="line">      <span class="keyword">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line">        _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class="line">        <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (node._needsLayout &amp;&amp; node.owner == <span class="keyword">this</span>)</span><br><span class="line">            node._layoutWithoutResize();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里会遍历dirtyNodes数组。这个数组里放置的是需要重新做布局的RenderObject。遍历之前会对dirtyNodes数组按照其在render tree中的深度做个排序。这里的排序和我们在构建（build）阶段遇到的对element tree的排序一样。排序以后会优先处理上层节点。因为布局的时候会递归处理子节点，这样如果先处理上层节点的话，就避免了后续重复布局下层节点。<br>之后就会调用RenderObject._layoutWithoutResize()来让节点自己做布局了。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _layoutWithoutResize() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      performLayout();</span><br><span class="line">      markNeedsSemanticsUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">    markNeedsPaint();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在RenderObject中，函数performLayout()需要其子类自行实现。因为有各种各样的布局，就需要子类个性化的实现自己的布局逻辑。在布局完成以后，会将自身的_needsLayout标志置为false。回头看一下上一个函数，在循环体里，只有_needsLayout是true的情况下才会调用_layoutWithoutResize()。<br>我们知道在Flutter中布局，渲染都是由RenderObject完成的,更具体的说应该是RenderBox。大部分页面元素使用的是盒子约束。<br>那么参数是如何传递到RenderBox的呢？<br>Container.build() 会返回一个 ConstrainedBox</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstrainedBox</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ConstrainedBox(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.constraints,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(constraints != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(constraints.debugAssertIsValid()),</span><br><span class="line">       <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The additional constraints to impose on the child.</span></span></span><br><span class="line">  <span class="keyword">final</span> BoxConstraints constraints;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderConstrainedBox createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RenderConstrainedBox(additionalConstraints: constraints);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, RenderConstrainedBox renderObject) &#123;</span><br><span class="line">    renderObject.additionalConstraints = constraints;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConstrainedBox 会创建 RenderConstrainedBox</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderConstrainedBox</span> <span class="keyword">extends</span> <span class="title">RenderProxyBox</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  RenderConstrainedBox(&#123;</span><br><span class="line">    RenderBox child,</span><br><span class="line">    <span class="meta">@required</span> BoxConstraints additionalConstraints,</span><br><span class="line">  &#125;) :</span><br><span class="line">       _additionalConstraints = additionalConstraints,</span><br><span class="line">       <span class="keyword">super</span>(child);</span><br><span class="line"></span><br><span class="line">  BoxConstraints _additionalConstraints;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      child.layout(_additionalConstraints.enforce(constraints), parentUsesSize: <span class="keyword">true</span>);</span><br><span class="line">      size = child.size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      size = _additionalConstraints.enforce(constraints).constrain(Size.zero);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>走到这里，其实这个RenderConstrainedBox就是相应的RnderBox，会通过performLayout 进行布局。<br>当有孩子节点的时候，这里会调用child.layout()请求孩子节点做布局。调用时要传入对孩子节点的约束constraints。</p>
<h1><span id="paint-绘制">paint 绘制</span></h1><p>Flutter框架中render tree负责布局和渲染。在渲染的时候，Flutter会遍历需要重绘的RenderObject子树来逐一绘制。我们在屏幕上看到的Flutter app页面其实是由不同的图层（layers）组合（compsite）而成的。这些图层是以树的形式组织起来的，也就是我们在Flutter中见到的又一个比较重要的树：layer tree。</p>
<p><img src="https://raw.githubusercontent.com/pacoblack/BlogImages/master/flutter_base/flutter6.webp"><br>上图是Flutter框架渲染机制的一个示意图。上方绿色方框里的内容可以认为就是本系列文章的关注所在。也就是Flutter框架渲染流水线运行的地方。可见，整个渲染流水线是运行在UI线程里的，以Vsync信号为驱动，在框架渲染完成之后会输出layer tree。layer tree被送入engine，engine会把layer tree调度到GPU线程，在GPU线程内合成（compsite）layer tree，然后由Skia 2D渲染引擎渲染后送入GPU显示。这里提到layer tree是因为我们即将要分析的渲染流水线绘制阶段最终输出就是这样的layer tree。所以绘制阶段并不是简单的调用paint()函数这么简单了，而是很多地方都涉及到layer tree的管理。</p>
<h2><span id="layer">layer</span></h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Layer</span> <span class="keyword">extends</span> <span class="title">AbstractNode</span> <span class="title">with</span> <span class="title">DiagnosticableTreeMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ContainerLayer <span class="keyword">get</span> parent =&gt; <span class="keyword">super</span>.parent;</span><br><span class="line"></span><br><span class="line">  Layer <span class="keyword">get</span> nextSibling =&gt; _nextSibling;</span><br><span class="line">  Layer _nextSibling;</span><br><span class="line"></span><br><span class="line">  Layer <span class="keyword">get</span> previousSibling =&gt; _previousSibling;</span><br><span class="line">  Layer _previousSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Layer是个抽象类，和RenderObject一样，继承自AbstractNode。表明它也是个树形结构。属性parent代表其父节点，类型是ContainerLayer。这个类继承自Layer。只有ContainerLayer类型及其子类的图层可以拥有孩子，其他类型的Layer子类都是叶子图层。nextSibling和previousSibling表示同一图层的前一个和后一个兄弟节点，也就是图层孩子节点们是用双向链表存储的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerLayer</span> <span class="keyword">extends</span> <span class="title">Layer</span> </span>&#123;</span><br><span class="line">  Layer _firstChild;</span><br><span class="line">  Layer _lastChild;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> append(Layer child) &#123;</span><br><span class="line">    adoptChild(child);</span><br><span class="line">    child._previousSibling = lastChild;</span><br><span class="line">    <span class="keyword">if</span> (lastChild != <span class="keyword">null</span>)</span><br><span class="line">      lastChild._nextSibling = child;</span><br><span class="line">    _lastChild = child;</span><br><span class="line">    _firstChild ??= child;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _removeChild(Layer child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child._previousSibling == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _firstChild = child._nextSibling;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      child._previousSibling._nextSibling = child.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child._nextSibling == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _lastChild = child.previousSibling;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      child.nextSibling._previousSibling = child.previousSibling;</span><br><span class="line">    &#125;</span><br><span class="line">    child._previousSibling = <span class="keyword">null</span>;</span><br><span class="line">    child._nextSibling = <span class="keyword">null</span>;</span><br><span class="line">    dropChild(child);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> removeAllChildren() &#123;</span><br><span class="line">    Layer child = firstChild;</span><br><span class="line">    <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> Layer next = child.nextSibling;</span><br><span class="line">      child._previousSibling = <span class="keyword">null</span>;</span><br><span class="line">      child._nextSibling = <span class="keyword">null</span>;</span><br><span class="line">      dropChild(child);</span><br><span class="line">      child = next;</span><br><span class="line">    &#125;</span><br><span class="line">    _firstChild = <span class="keyword">null</span>;</span><br><span class="line">    _lastChild = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ContainerLayer增加了头和尾两个孩子节点属性，并提供了新增及删除孩子节点的方法。<br>ContainerLayer的子类有OffsetLayer,ClipRectLayer等等。<br>叶子类型的图层有TextureLayer,PlatformViewLayer, PerformanceOverlayLayer，PictureLayer等等，框架中大部分RenderObject的绘制的目标图层都是PictureLayer。</p>
<h2><span id="flushcompositingbits">flushCompositingBits()</span></h2><p>这个方法是在drawFrame中被调用的，也是绘制需要进行的第一步。这个调用是用来更新render tree 中RenderObject的_needsCompositing标志位的。<br>通过方法markNeedsCompositingBitsUpdate()完成</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsCompositingBitsUpdate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_needsCompositingBitsUpdate)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    _needsCompositingBitsUpdate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line">      <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">      <span class="keyword">if</span> (parent._needsCompositingBitsUpdate)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (!isRepaintBoundary &amp;&amp; !parent.isRepaintBoundary) &#123;</span><br><span class="line">        parent.markNeedsCompositingBitsUpdate();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">      owner._nodesNeedingCompositingBitsUpdate.add(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个调用会从当前节点往上找，把所有父节点的_needsCompositingBitsUpdate标志位都置位true。直到自己或者父节点的isRepaintBoundary为true。最后会把自己加入到PipelineOwner的_nodesNeedingCompositingBitsUpdate列表里面。而函数调用pipelineOwner.flushCompositingBits()正是用来处理这个列表的。</p>
<p>flushCompositingBits()源码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushCompositingBits() &#123;</span><br><span class="line"></span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth);</span><br><span class="line">    <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> _nodesNeedingCompositingBitsUpdate) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._needsCompositingBitsUpdate &amp;&amp; node.owner == <span class="keyword">this</span>)</span><br><span class="line">        node._updateCompositingBits();</span><br><span class="line">    &#125;</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.clear();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>首先把列表_nodesNeedingCompositingBitsUpdate按照节点在树中的深度排序。然后遍历调用node._updateCompositingBits().<br>_updateCompositingBits()做的事情是从当前节点往下找，如果某个子节点isRepaintBoundary为true或alwaysNeedsCompositing为true则设置_needsCompositing为true。子节点这个标志位为true的话，那么父节点的该标志位也会被设置为true。如果_needsCompositing发生了变化，那么会调用markNeedsPaint()通知渲染流水线本RenderObject需要重绘了。为啥要重绘呢？原因是<code>RenderObject</code>所在的图层(layer)可能发生了变化。</p>
<h3><span id="renderobject的标志位">RenderObject的标志位</span></h3><blockquote>
<p>bool _needsCompositing：标志自身或者某个孩子节点有合成层（compositing layer）。如果当前节点需要合成，那么所有祖先节点也都需要合成。<br>bool _needsCompositingBitsUpdate：标志当前节点是否需要更新_needsCompositing。这个标志位由下方的markNeedsCompositingBitsUpdate()函数设置。<br>bool get isRepaintBoundary &#x3D;&gt; false;：标志当前节点是否与父节点分开来重绘。当这个标志位为true的时候，父节点重绘的时候子节点不一定也需要重绘，同样的，当自身重绘的时候父节点不一定需要重绘。此标志位为true的RenderObject有render tree的根节点RenderView，有我们熟悉的RenderRepaintBoundary，TextureBox等。<br>bool get alwaysNeedsCompositing &#x3D;&gt; false;：标志当前节点是否总是需要合成。这个标志位为true的话意味着当前节点绘制的时候总是会新开合成层（composited layer）。例如TextureBox, 以及我们熟悉的显示运行时性能的RenderPerformanceOverlay等。</p>
</blockquote>
<h2><span id="flushpaint">flushPaint()</span></h2><p>函数flushPaint()处理的是之前加入到列表_nodesNeedingPaint里的节点。当某个RenderObject需要被重绘的时候会调用markNeedsPaint()</p>
<p>函数markNeedsPaint()首先做的是把自己的标志位_needsPaint设置为true。然后会向上查找最近的一个isRepaintBoundary为true的祖先节点。直到找到这样的节点，才会把这个节点加入到_nodesNeedingPaint列表中，也就是说，并不是任意一个需要重绘的RenderObject就会被加入这个列表，而是往上找直到找到最近的一个isRepaintBoundary为true才会放入这个列表，换句话说，这个列表里只有isRepaintBoundary为true这种类型的节点。也就是说重绘的起点是从“重绘边界”开始的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushPaint() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class="line">    _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class="line">    <span class="comment">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class="line">    <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._needsPaint &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node._layer.attached) &#123;</span><br><span class="line">          PaintingContext.repaintCompositedChild(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          node._skippedPaintingOnLayer();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在处理需要重绘的节点的时候，会先给这些节点做个排序，这里需要注意的是，和之前flushLayout()里的排序不同，这里的排序是深度度深的节点在前。在循环体里，会判断当前节点的_layer属性是否处于attached的状态。如果_layer.attached为true的话调用PaintingContext.repaintCompositedChild(node);去做绘制，否则的话调用node._skippedPaintingOnLayer()将自身以及到上层绘制边界之间的节点的_needsPaint全部置为true。这样在下次_layer.attached变为true的时候会直接绘制。</p>
<p>从上述代码也可以看出，重绘边界相当于把Flutter的绘制做了分块处理，重绘的从上层重绘边界开始，到下层重绘边界为止，在此之间的RenderObject都需要重绘，而边界之外的就可能不需要重绘，这也是一个性能上的考虑，尽量避免不必要的绘制。所以如何合理安排RepaintBoundary是我们在做Flutter app的性能优化时候需要考虑的一个方向。<br>这里的_layer属性就是我们之前说的图层，这个属性只有绘制边界的RenderObject才会有值。一般的RenderObject这个属性是null。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _repaintCompositedChild(</span><br><span class="line">  RenderObject child, &#123;</span><br><span class="line">  <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span>,</span><br><span class="line">  PaintingContext childContext,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child._layer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    child._layer = OffsetLayer();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    child._layer.removeAllChildren();</span><br><span class="line">  &#125;</span><br><span class="line">  childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class="line">  child._paintWithContext(childContext, Offset.zero);</span><br><span class="line">  childContext.stopRecordingIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数_repaintCompositedChild()会先检查RenderObject的图层属性，为空则新建一个OffsetLayer实例。如果图层已经存在的话就把孩子清空。<br>如果没有PaintingContext的话会新建一个，然后让开始绘制。我们先来看一下PaintingContext这个类：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintingContext</span> <span class="keyword">extends</span> <span class="title">ClipContext</span> </span>&#123;</span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  PaintingContext(<span class="keyword">this</span>._containerLayer, <span class="keyword">this</span>.estimatedBounds)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ContainerLayer _containerLayer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Rect estimatedBounds;</span><br><span class="line"></span><br><span class="line">  PictureLayer _currentLayer;</span><br><span class="line">  ui.PictureRecorder _recorder;</span><br><span class="line">  Canvas _canvas;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Canvas <span class="keyword">get</span> canvas &#123;</span><br><span class="line">    <span class="keyword">if</span> (_canvas == <span class="keyword">null</span>)</span><br><span class="line">      _startRecording();</span><br><span class="line">    <span class="keyword">return</span> _canvas;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _startRecording() &#123;</span><br><span class="line">    _currentLayer = PictureLayer(estimatedBounds);</span><br><span class="line">    _recorder = ui.PictureRecorder();</span><br><span class="line">    _canvas = Canvas(_recorder);</span><br><span class="line">    _containerLayer.append(_currentLayer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> stopRecordingIfNeeded() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_isRecording)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    _currentLayer.picture = _recorder.endRecording();</span><br><span class="line">    _currentLayer = <span class="keyword">null</span>;</span><br><span class="line">    _recorder = <span class="keyword">null</span>;</span><br><span class="line">    _canvas = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>类PaintingContext字面意思是绘制上下文，其属性_containerLayer是容器图层，来自构造时的入参。也就是说PaintingContext是和容器图层关联的。接下来还有PictureLayer类型的_currentLayer属性, ui.PictureRecorder类型的_recorder属性和我们熟悉的Canvas类型的属性_canvas。函数_startRecording() 实例化了这几个属性。_recorder用来录制绘制命令，_canvas绑定一个录制器。最后，_currentLayer会作为子节点加入到_containerLayer中。有开始那么就会有结束，stopRecordingIfNeeded()用来结束当前绘制的录制。结束时会把绘制完毕的Picture赋值给当前的PictureLayer.picture。<br>有了PaintingContext以后，就可以调用RenderObject._paintWithContext()开始绘制了，这个函数会直接调用到我们熟悉的RenderObject.paint(context, offset)，我们知道函数paint()由RenderObject子类自己实现。从之前的源码分析我们知道绘制起点都是“绘制边界”。这里我们就拿我们熟悉的一个“绘制边界”，RenderRepaintBoundary，为例来走一下绘制流程，它的绘制函数的实现在RenderProxyBoxMixin类中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">    context.paintChild(child, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个调用又回到了PaintingContext的paintChild()方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paintChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child.isRepaintBoundary) &#123;</span><br><span class="line">    stopRecordingIfNeeded();</span><br><span class="line">    _compositeChild(child, offset);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    child._paintWithContext(<span class="keyword">this</span>, offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会检查子节点是不是绘制边界，如果不是的话，就是普通的绘制了，接着往下调用_paintWithContext()，继续往当前的PictureLayer上绘制。如果是的话就把当前的绘制先停掉。然后调用_compositeChild(child, offset);</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _compositeChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child._needsPaint) &#123;</span><br><span class="line">    repaintCompositedChild(child, debugAlsoPaintedParent: <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  child._layer.offset = offset;</span><br><span class="line">  appendLayer(child._layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个子绘制边界被标记为需要重绘的话，那么就调用repaintCompositedChild()来重新生成图层然后重绘。如果这个子绘制边界没有被标记为需要重绘的话，就跳过了重新生成图层和重绘。最后只需要把子图层加入到当前容器图层中就行了。<br>上面说的是子节点是绘制边界的时候的绘制流程，那如果子节点是普通的一个RenderObject呢？这里就拿Flutter app出错控件的绘制做个例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      context.canvas.drawRect(offset &amp; size, Paint() .. color = backgroundColor);</span><br><span class="line">      <span class="built_in">double</span> width;</span><br><span class="line">      <span class="keyword">if</span> (_paragraph != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// See the comment in the RenderErrorBox constructor. This is not the</span></span><br><span class="line">        <span class="comment">// code you want to be copying and pasting. :-)</span></span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderBox) &#123;</span><br><span class="line">          <span class="keyword">final</span> RenderBox parentBox = parent;</span><br><span class="line">          width = parentBox.size.width;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          width = size.width;</span><br><span class="line">        &#125;</span><br><span class="line">        _paragraph.layout(ui.ParagraphConstraints(width: width));</span><br><span class="line"></span><br><span class="line">        context.canvas.drawParagraph(_paragraph, offset);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally left empty.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这看起来就像个正常的绘制了，我们会用来自PaintingContext的画布canvas来绘制矩形，绘制文本等等。从前面的分析也可以看出，这里的绘制都是在一个PictureLayer的图层上所做的。<br>至此 pipelineOwner.flushPaint();这个函数的调用就跑完了，通过分析我们可以知道，绘制工作其实主要是在这个函数中完成的。接下来我们再来看一下绘制流程的最后一个重要的函数调用：</p>
<h2><span id="compositeframe">compositeFrame()</span></h2><p>这里的renderView就是我们之前说的render tree的根节点。这个函数调用主要是把整个layer tree生成scene送到engine去显示。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> compositeFrame() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> ui.SceneBuilder builder = ui.SceneBuilder();</span><br><span class="line">      <span class="keyword">final</span> ui.Scene scene = layer.buildScene(builder);</span><br><span class="line">      <span class="keyword">if</span> (automaticSystemUiAdjustment)</span><br><span class="line">        _updateSystemChrome();</span><br><span class="line">      _<span class="built_in">window</span>.render(scene);</span><br><span class="line">      scene.dispose();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ui.SceneBuilder()最终调用Native方法SceneBuilder_constructor。也就是说ui.SceneBuilder实例是由engine创建的。接下来就是调用layer.buildScene(builder)方法，这个方法会返回一个ui.Scene实例。由于方法compositeFrame()的调用者是renderView。所以这里这个layer是来自renderView的属性，我们前面说过只有绘制边界节点才有layer。所以可见render tree的根节点renderView也是一个绘制边界。那么这个layer是从哪里来的呢？在之前的初始化中我们提到过，框架初始化的过程中renderView会调度开天辟地的第一帧：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleInitialFrame() &#123;</span><br><span class="line">    scheduleInitialLayout();</span><br><span class="line">    scheduleInitialPaint(_updateMatricesAndCreateNewRootLayer());</span><br><span class="line">    owner.requestVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Layer _updateMatricesAndCreateNewRootLayer() &#123;</span><br><span class="line">    _rootTransform = configuration.toMatrix();</span><br><span class="line">    <span class="keyword">final</span> ContainerLayer rootLayer = TransformLayer(transform: _rootTransform);</span><br><span class="line">    rootLayer.attach(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> rootLayer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> scheduleInitialPaint(ContainerLayer rootLayer) &#123;</span><br><span class="line">    _layer = rootLayer;</span><br><span class="line">    owner._nodesNeedingPaint.add(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在方法_updateMatricesAndCreateNewRootLayer()中，我们看到这里实例化了一个TransformLayer。TransformLayer继承自OffsetLayer。构造时需要传入Matrix4类型的参数transform。这个Matrix4其实和我们在Android中见到的Matrix是一回事。代表着矩阵变换。这里的transform来自我们之前讲过的ViewConfiguration，它就是把设备像素比例转化成了矩阵的形式。最终这个layer关联上了renderView。所以这里这个TransformLayer其实也是layer tree的根节点了。<br>回到我们的绘制流程。layer.buildScene(builder);这个调用我们自然是去TransformLayer里找了，但这个方法是在其父类OffsetLayer内，从这个调用开始就都是对图层进行操作，最终把layer tree转换为场景scene：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ui.Scene buildScene(ui.SceneBuilder builder) &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;PictureLayer&gt; temporaryLayers;</span><br><span class="line">    updateSubtreeNeedsAddToScene();</span><br><span class="line">    addToScene(builder);</span><br><span class="line">    <span class="keyword">final</span> ui.Scene scene = builder.build();</span><br><span class="line">    <span class="keyword">return</span> scene;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>函数调用updateSubtreeNeedsAddToScene();会遍历layer tree来设置_subtreeNeedsAddToScene标志位，如果有任意子图层的添加、删除操作，则该子图层及其祖先图层都会被置上_subtreeNeedsAddToScene标志位。然后会调用addToScene(builder);</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@override</span></span><br><span class="line">ui.EngineLayer addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) &#123;</span><br><span class="line">  _lastEffectiveTransform = transform;</span><br><span class="line">  <span class="keyword">final</span> Offset totalOffset = offset + layerOffset;</span><br><span class="line">  <span class="keyword">if</span> (totalOffset != Offset.zero) &#123;</span><br><span class="line">    _lastEffectiveTransform = Matrix4.translationValues(totalOffset.dx, totalOffset.dy, <span class="number">0.0</span>)</span><br><span class="line">      ..multiply(_lastEffectiveTransform);</span><br><span class="line">  &#125;</span><br><span class="line">  builder.pushTransform(_lastEffectiveTransform.storage);</span><br><span class="line">  addChildrenToScene(builder);</span><br><span class="line">  builder.pop();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// this does not return an engine layer yet.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>builder.pushTransform会调用到engine层。相当于告诉engine这里我要加一个变换图层。然后调用ddChildrenToScene(builder)将子图层加入场景中，完了还要把之前压栈的变换图层出栈。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> addChildrenToScene(ui.SceneBuilder builder, [ Offset childOffset = Offset.zero ]) &#123;</span><br><span class="line">    Layer child = firstChild;</span><br><span class="line">    <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (childOffset == Offset.zero) &#123;</span><br><span class="line">        child._addToSceneWithRetainedRendering(builder);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.addToScene(builder, childOffset);</span><br><span class="line">      &#125;</span><br><span class="line">      child = child.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这就是遍历添加子图层的调用。主要还是逐层向下的调用addToScene()。这个方法不同的图层会有不同的实现，对于容器类图层而言，主要就是做三件事：1.添加自己图层的效果然后入栈，2.添加子图层，3. 出栈。<br>在所有图层都处理完成之后。回到renderView.compositeFrame()，可见最后会把处理完得到的场景通过_window.render(scene);调用送入engine去显示了。<br>至此渲染流水线的绘制(paint)阶段就算是跑完了。<br>等等，好像缺了点什么，在分析绘制的过程中我们看到有个主要的调用pipelineOwner.flushCompositingBits()是在更新render tree里节点的_needsCompositing标志位的。但是我们这都把流程说完了，貌似没有看到这个标志位在哪里用到啊。这个标志位肯定在哪里被用到了，否则我们费这么大劲更新有啥用呢？回去再研究一下代码……<br>这个标志位某些RenderObject在其paint()函数中会用到，作用呢，就体现在PaintingContext的这几个函数的调用上了：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> pushClipRect(<span class="built_in">bool</span> needsCompositing, Offset offset, Rect clipRect, PaintingContextCallback painter, &#123; Clip clipBehavior = Clip.hardEdge &#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> Rect offsetClipRect = clipRect.shift(offset);</span><br><span class="line">  <span class="keyword">if</span> (needsCompositing) &#123;</span><br><span class="line">    pushLayer(ClipRectLayer(clipRect: offsetClipRect, clipBehavior: clipBehavior), painter, offset, childPaintBounds: offsetClipRect);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    clipRectAndPaint(offsetClipRect, clipBehavior, offsetClipRect, () =&gt; painter(<span class="keyword">this</span>, offset));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> pushClipRRect(<span class="built_in">bool</span> needsCompositing, Offset offset, Rect bounds, RRect clipRRect, PaintingContextCallback painter, &#123; Clip clipBehavior = Clip.antiAlias &#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> Rect offsetBounds = bounds.shift(offset);</span><br><span class="line">  <span class="keyword">final</span> RRect offsetClipRRect = clipRRect.shift(offset);</span><br><span class="line">  <span class="keyword">if</span> (needsCompositing) &#123;</span><br><span class="line">    pushLayer(ClipRRectLayer(clipRRect: offsetClipRRect, clipBehavior: clipBehavior), painter, offset, childPaintBounds: offsetBounds);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    clipRRectAndPaint(offsetClipRRect, clipBehavior, offsetBounds, () =&gt; painter(<span class="keyword">this</span>, offset));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> pushClipPath(<span class="built_in">bool</span> needsCompositing, Offset offset, Rect bounds, Path clipPath, PaintingContextCallback painter, &#123; Clip clipBehavior = Clip.antiAlias &#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> Rect offsetBounds = bounds.shift(offset);</span><br><span class="line">  <span class="keyword">final</span> Path offsetClipPath = clipPath.shift(offset);</span><br><span class="line">  <span class="keyword">if</span> (needsCompositing) &#123;</span><br><span class="line">    pushLayer(ClipPathLayer(clipPath: offsetClipPath, clipBehavior: clipBehavior), painter, offset, childPaintBounds: offsetBounds);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    clipPathAndPaint(offsetClipPath, clipBehavior, offsetBounds, () =&gt; painter(<span class="keyword">this</span>, offset));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> pushTransform(<span class="built_in">bool</span> needsCompositing, Offset offset, Matrix4 transform, PaintingContextCallback painter) &#123;</span><br><span class="line">  <span class="keyword">final</span> Matrix4 effectiveTransform = Matrix4.translationValues(offset.dx, offset.dy, <span class="number">0.0</span>)</span><br><span class="line">    ..multiply(transform)..translate(-offset.dx, -offset.dy);</span><br><span class="line">  <span class="keyword">if</span> (needsCompositing) &#123;</span><br><span class="line">    pushLayer(</span><br><span class="line">      TransformLayer(transform: effectiveTransform),</span><br><span class="line">      painter,</span><br><span class="line">      offset,</span><br><span class="line">      childPaintBounds: MatrixUtils.inverseTransformRect(effectiveTransform, estimatedBounds),</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    canvas</span><br><span class="line">      ..save()</span><br><span class="line">      ..transform(effectiveTransform.storage);</span><br><span class="line">    painter(<span class="keyword">this</span>, offset);</span><br><span class="line">    canvas</span><br><span class="line">      ..restore();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>needsCompositing作为这几个函数的入参，从代码可见其作用主要是控制这几种特殊的绘制操作的具体实现方式，如果needsCompositing为true的话，则会调用pushLayer，参数我们之前见过的各种图层</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> pushLayer(ContainerLayer childLayer, PaintingContextCallback painter, Offset offset, &#123; Rect childPaintBounds &#125;) &#123;</span><br><span class="line">  stopRecordingIfNeeded();</span><br><span class="line">  appendLayer(childLayer);</span><br><span class="line">  <span class="keyword">final</span> PaintingContext childContext = createChildContext(childLayer, childPaintBounds ?? estimatedBounds);</span><br><span class="line">  painter(childContext, offset);</span><br><span class="line">  childContext.stopRecordingIfNeeded();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line">PaintingContext createChildContext(ContainerLayer childLayer, Rect bounds) &#123;</span><br><span class="line">  <span class="keyword">return</span> PaintingContext(childLayer, bounds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程基本上和我们之前看到的重绘的时候新增一个图层的操作是一样的。<br>而如果needsCompositing为false的话则走的是canvas的各种变换了。大家感兴趣的话可以去看一下源码，这里就不细说了。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/flutter/" rel="tag"># Flutter</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/27/Hexo-%E5%B0%8F%E7%99%BD%E6%B5%81%E7%A8%8B/" rel="prev" title="Hexo 小白流程">
      <i class="fa fa-chevron-left"></i> Hexo 小白流程
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/09/29/Android-Project-Butter/" rel="next" title="Android Project Butter">
      Android Project Butter <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">总览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.1.</span> <span class="nav-text">ensureInitialized()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.1.</span> <span class="nav-text">GestureBinding 手势绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.2.</span> <span class="nav-text">ServicesBinding 服务绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.3.</span> <span class="nav-text">SchedulerBinding 调度绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.4.</span> <span class="nav-text">PaintingBinding 绘制绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.5.</span> <span class="nav-text">SemanticsBinding 辅助功能绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.6.</span> <span class="nav-text">RendererBinding渲染绑定(比较重要)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.7.</span> <span class="nav-text">WidgetsBinding 组件绑定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.2.</span> <span class="nav-text">attachRootWidget(app)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.3.</span> <span class="nav-text">scheduleWarmUpFrame()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">绘制组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.1.</span> <span class="nav-text">Widget</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.1.1.</span> <span class="nav-text">StatelessWidget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.1.2.</span> <span class="nav-text">StatefulWidget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.1.3.</span> <span class="nav-text">State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.1.4.</span> <span class="nav-text">InheritedWidget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.1.5.</span> <span class="nav-text">RenderObjectWidget</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.2.</span> <span class="nav-text">Element</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.2.1.</span> <span class="nav-text">ComponentElement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.2.2.</span> <span class="nav-text">StatelessElement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.2.3.</span> <span class="nav-text">StatefulElement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.2.4.</span> <span class="nav-text">InheritedElement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.2.5.</span> <span class="nav-text">RenderObjectElement</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.3.</span> <span class="nav-text">RenderObject</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">flutter运行框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">4.1.</span> <span class="nav-text">State.setState()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">4.2.</span> <span class="nav-text">Vsync信号接收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">4.2.1.</span> <span class="nav-text">onBeginFrame</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">4.2.2.</span> <span class="nav-text">onDrawFrame</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">4.2.3.</span> <span class="nav-text">build 构建阶段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">5.</span> <span class="nav-text">动画</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">6.</span> <span class="nav-text">Layout 布局</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">7.</span> <span class="nav-text">paint 绘制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">7.1.</span> <span class="nav-text">layer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">7.2.</span> <span class="nav-text">flushCompositingBits()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">7.2.1.</span> <span class="nav-text">RenderObject的标志位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">7.3.</span> <span class="nav-text">flushPaint()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">7.4.</span> <span class="nav-text">compositeFrame()</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="pacoblack"
      src="/images/avatar1.jpeg">
  <p class="site-author-name" itemprop="name">pacoblack</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/pacoblack" title="GitHub → https://github.com/pacoblack" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:pacoson.wang@gmail.com" title="E-Mail → mailto:pacoson.wang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pacoblack</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='99' src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css" class="aplayer-style-marker">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" class="aplayer-script-marker"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js" class="meting-script-marker"></script>
  <div id="aplayer-AXqIDvNX"
      class="aplayer aplayer-tag-marker meting-tag-marker aplayer-fixed"
      data-id="71075946"
      data-server="netease"
      data-type="playlist"
      data-mode="circulation"
      data-autoplay="false"
      data-mutex="true"
      data-listmaxheight="340px"
      data-preload="auto"
      data-fixed="true"
      data-lrctype="0"
      data-theme="#555"></div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
