<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pacoblack.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="mmkv速度可以说是当前所有同类型中速度最快，性能最优的库。">
<meta property="og:type" content="article">
<meta property="og:title" content="mmkv简单分析">
<meta property="og:url" content="https://pacoblack.github.io/2021/11/15/mmkv%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="我爱学习">
<meta property="og:description" content="mmkv速度可以说是当前所有同类型中速度最快，性能最优的库。">
<meta property="og:locale">
<meta property="article:published_time" content="2021-11-15T10:12:02.000Z">
<meta property="article:modified_time" content="2021-11-16T03:35:23.917Z">
<meta property="article:author" content="pacoblack">
<meta property="article:tag" content="android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://pacoblack.github.io/2021/11/15/mmkv%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>mmkv简单分析 | 我爱学习</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">我爱学习</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这只是一场演习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="主页 fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="标签 fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="分类 fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="归档 fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="关于 fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://pacoblack.github.io/2021/11/15/mmkv%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpeg">
      <meta itemprop="name" content="pacoblack">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我爱学习">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mmkv简单分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-15 18:12:02" itemprop="dateCreated datePublished" datetime="2021-11-15T18:12:02+08:00">2021-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-16 11:35:23" itemprop="dateModified" datetime="2021-11-16T11:35:23+08:00">2021-11-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>mmkv速度可以说是当前所有同类型中速度最快，性能最优的库。</p>
<span id="more"></span>
<h1><span id="sharedpreferences缺点">SharedPreferences缺点</span></h1><ol>
<li>跨进程不安全 — 就算使用了MODE_MULTI_PROCESS，频繁的写入还是会会造成数据丢失。</li>
<li>加载缓慢 — SharedPreferences使用异步加载，由于线程没有设置优先级，按照默认的线程优先级会造成时间片抢占机会小导致主线程长时间的等待。</li>
<li>全量写入 — 无论是调用 commit() 还是 apply()，即使我们只改动其中的一个条目，都会把整个内容全部写到文件</li>
<li>卡顿 — 由于提供了异步落盘的 apply 机制，在崩溃或者其他一些异常情况可能会导致数据丢失。所以当应用收到系统广播，或者被调用 onPause 等一些时机，系统会强制把所有的 SharedPreferences 对象数据落地到磁盘。如果没有落地完成，这时候主线程会被一直阻塞。这样非常容易造成卡顿，甚至是 ANR，从线上数据来看 SP 卡顿占比一般会超过 5%</li>
</ol>
<h1><span id="mmkv">mmkv</span></h1><h2><span id="简单介绍">简单介绍</span></h2><p>mmkv其实和SharePrefences一样，有增删查改四种操作。<br>MMKV作为一个键值对存储组件，也对了存储对象的序列化方式进行了优化。常用的方式比如有json，Twitter的Serial。MMKV使用的是Google开源的序列化方案:Protocol Buffers。<br>Protocol Buffers这个方案比起json来说就高级不少：</p>
<ol>
<li>从体积上，使用了二进制的压缩。比起json小上不少。</li>
<li>兼容性上，Protocol Buffers有自己的语法，可以跨语言跨平台。</li>
<li>使用成本上，比起json就要高上不少。需要定义.proto 文件，并用工具生成对应的辅助类。辅助类特有一些序列化的辅助方法，所有要序列化的对象，都需要先转化为辅助类的对象，这让序列化代码跟业务代码大量耦合，是侵入性较强的一种方式。</li>
</ol>
<h2><span id="具体用法">具体用法</span></h2><p>使用前请初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MMKV.initialize(this)</span><br></pre></td></tr></table></figure>
<h3><span id="入键值对">入键值对</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var mmkv = MMKV.defaultMMKV()</span><br><span class="line">mmkv.encode(&quot;bool&quot;,true)</span><br><span class="line">mmkv.encode(&quot;int&quot;,1)</span><br><span class="line">mmkv.encode(&quot;String&quot;,&quot;test&quot;)</span><br><span class="line">mmkv.encode(&quot;float&quot;,1.0f)</span><br><span class="line">mmkv.encode(&quot;double&quot;,1.0)</span><br></pre></td></tr></table></figure>
<p>当然mmkv除了能够写入这些基本类型，只要SharePrefences支持的，它也一定能够支持。</p>
<h3><span id="读取键值对">读取键值对</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var mmkv = MMKV.defaultMMKV()</span><br><span class="line">var bo = mmkv.decodeBool(&quot;bool&quot;)</span><br><span class="line">Log.e(TAG,&quot;bool:$&#123;bo&#125;&quot;)</span><br><span class="line">var i = mmkv.decodeInt(&quot;int&quot;)</span><br><span class="line">Log.e(TAG,&quot;int:$&#123;i&#125;&quot;)</span><br><span class="line">var s = mmkv.decodeString(&quot;String&quot;)</span><br><span class="line">Log.e(TAG,&quot;String:$&#123;s&#125;&quot;)</span><br><span class="line">var f = mmkv.decodeFloat(&quot;float&quot;)</span><br><span class="line">Log.e(TAG,&quot;float:$&#123;f&#125;&quot;)</span><br><span class="line">var d = mmkv.decodeDouble(&quot;double&quot;)</span><br><span class="line">Log.e(TAG,&quot;double:$&#123;d&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>同上，每一个key读取的数据类型就是decodexxx对应的类型名字。使用起来十分简单。</p>
<h3><span id="删除和查键值对">删除和查键值对</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mmkv = MMKV.defaultMMKV()</span><br><span class="line">mmkv.removeValueForKey(&quot;String&quot;)</span><br><span class="line">mmkv.removeValuesForKeys(arrayOf(&quot;int&quot;,&quot;bool&quot;))</span><br><span class="line">mmkv.containsKey(&quot;String&quot;)</span><br></pre></td></tr></table></figure>
<p>能够删除单个key对应的value，也能删除多个key分别对应的value。containsKey判断mmkv的磁盘缓存中是否存在对应的key。</p>
<h3><span id="其他用法">其他用法</span></h3><p>mmkv和SharePrefences一样，还能根据模块和业务划分对应的缓存文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mmkv = MMKV.mmkvWithID(&quot;a&quot;)</span><br><span class="line">mmkv.encode(&quot;String&quot;,&quot;test111&quot;)</span><br></pre></td></tr></table></figure>
<p>这里创建了一个id为a的实例在磁盘中，进行数据的缓存。</p>
<h3><span id="多进程缓存">多进程缓存</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mmkv = MMKV.mmkvWithID(&quot;a&quot;,MMKV.MULTI_PROCESS_MODE)</span><br></pre></td></tr></table></figure>

<h3><span id="ashmem匿名内存">Ashmem匿名内存</span></h3><p>MMKV可以使用Ashmem的匿名内存进行更加快速的大对象传输：<br>进程1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m_ashmemMMKV = MMKV.mmkvWithAshmemID(BenchMarkBaseService.this, id, AshmemMMKV_Size,</span><br><span class="line">                                                 MMKV.MULTI_PROCESS_MODE, CryptKey);</span><br><span class="line">            m_ashmemMMKV.encode(&quot;bool&quot;, true);</span><br></pre></td></tr></table></figure>
<h3><span id="mmkv迁移到shareprefences">MMKV迁移到SharePrefences</span></h3><p>最重要的一点，mmkv把SharePrefences的缓存迁移到mmkv中，之后的使用就和SharePrefences一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var preferences = MMKV.mmkvWithID(&quot;myData&quot;)</span><br><span class="line">        var originPrefences = getSharedPreferences(&quot;myData&quot;, Context.MODE_PRIVATE)</span><br><span class="line">        preferences.importFromSharedPreferences(originPrefences)</span><br><span class="line">        originPrefences.edit().clear().commit()</span><br></pre></td></tr></table></figure>
<p>这里就是把SharedPreferences的myData数据迁移到mmkv中。当然如果我们需要保持SharePreferences的用法不变需要自己进行自定义一个SharePreferences。</p>
<h1><span id="mmkv源码介些">mmkv源码介些</span></h1><h2><span id="初始化">初始化</span></h2><h3><span id="java初始化">Java初始化</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static String initialize(Context context) &#123;</span><br><span class="line">        String root = context.getFilesDir().getAbsolutePath() + &quot;/mmkv&quot;;</span><br><span class="line">        MMKVLogLevel logLevel = MMKVLogLevel.LevelInfo;</span><br><span class="line">        return initialize(root, (MMKV.LibLoader)null, logLevel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String initialize(String rootDir, LibLoader loader, MMKVLogLevel logLevel) &#123;</span><br><span class="line">        if (loader != null) &#123;</span><br><span class="line">            if (BuildConfig.FLAVOR.equals(&quot;SharedCpp&quot;)) &#123;</span><br><span class="line">                loader.loadLibrary(&quot;c++_shared&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            loader.loadLibrary(&quot;mmkv&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (BuildConfig.FLAVOR.equals(&quot;SharedCpp&quot;)) &#123;</span><br><span class="line">                System.loadLibrary(&quot;c++_shared&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.loadLibrary(&quot;mmkv&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        MMKV.rootDir = rootDir;</span><br><span class="line">        jniInitialize(MMKV.rootDir, logLevel2Int(logLevel));</span><br><span class="line">        return rootDir;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>能看到实际上initialize分为如下几个步骤：</p>
<ol>
<li>创建一个app内的&#x2F;data&#x2F;data&#x2F;包名&#x2F;files&#x2F;mmkv的目录。所有的文件都保存在里面。</li>
<li>加载两个so库，c++_shared以及mmkv。</li>
</ol>
<p>这里有点迷惑，c++_shared是什么条件加载的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">defaultPublishConfig &quot;StaticCppRelease&quot;</span><br><span class="line">flavorDimensions &quot;stl_mode&quot;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        StaticCpp &#123;</span><br><span class="line">            dimension &quot;stl_mode&quot;</span><br><span class="line">            ext.artifactIdSuffix = &#x27;static&#x27;</span><br><span class="line">            externalNativeBuild &#123;</span><br><span class="line">                cmake &#123;</span><br><span class="line">                    arguments = [&quot;-DANDROID_STL=c++_static&quot;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SharedCpp &#123;</span><br><span class="line">            dimension &quot;stl_mode&quot;</span><br><span class="line">            ext.artifactIdSuffix = &#x27;&#x27;</span><br><span class="line">            externalNativeBuild &#123;</span><br><span class="line">                cmake &#123;</span><br><span class="line">                    arguments = [&quot;-DANDROID_STL=c++_shared&quot;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>能看到其实就是做这个判断。由于此时设置的是libc++的打包方式。此时BuildConfig.FLAVOR就是StaticCpp，就不会加载c++_shared。当然，如果我们已经使用了c++_shared库，则没有必要打包进去，使用defaultPublishConfig “SharedCppRelease”会尝试的查找动态链接库_shared。这样就能少2M的大小。</p>
<h4><span id="mmkv-native层的初始化">MMKV native层的初始化</span></h4><p>请注意一个前提的知识，jni的初始化，在调用了 System.loadLibrary之后，会通过dlopen把so加载到内存后，调用dlsym，调用jni中的JNI_OnLoad方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; JNIEXPORT JNICALL jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123;</span><br><span class="line">    g_currentJVM = vm;</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    if (vm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (g_cls) &#123;</span><br><span class="line">        env-&gt;DeleteGlobalRef(g_cls);</span><br><span class="line">    &#125;</span><br><span class="line">    static const char *clsName = &quot;com/tencent/mmkv/MMKV&quot;;</span><br><span class="line">    jclass instance = env-&gt;FindClass(clsName);</span><br><span class="line">    if (!instance) &#123;</span><br><span class="line">        MMKVError(&quot;fail to locate class: %s&quot;, clsName);</span><br><span class="line">        return -2;</span><br><span class="line">    &#125;</span><br><span class="line">    g_cls = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(instance));</span><br><span class="line">    if (!g_cls) &#123;</span><br><span class="line">        MMKVError(&quot;fail to create global reference for %s&quot;, clsName);</span><br><span class="line">        return -3;</span><br><span class="line">    &#125;</span><br><span class="line">    int ret = registerNativeMethods(env, g_cls);</span><br><span class="line">    if (ret != 0) &#123;</span><br><span class="line">        MMKVError(&quot;fail to register native methods for class %s, ret = %d&quot;, clsName, ret);</span><br><span class="line">        return -4;</span><br><span class="line">    &#125;</span><br><span class="line">    g_fileID = env-&gt;GetFieldID(g_cls, &quot;nativeHandle&quot;, &quot;J&quot;);</span><br><span class="line">    if (!g_fileID) &#123;</span><br><span class="line">        MMKVError(&quot;fail to locate fileID&quot;);</span><br><span class="line">        return -5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_callbackOnCRCFailID = env-&gt;GetStaticMethodID(g_cls, &quot;onMMKVCRCCheckFail&quot;, &quot;(Ljava/lang/String;)I&quot;);</span><br><span class="line">    if (!g_callbackOnCRCFailID) &#123;</span><br><span class="line">        MMKVError(&quot;fail to get method id for onMMKVCRCCheckFail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    g_callbackOnFileLengthErrorID = env-&gt;GetStaticMethodID(g_cls, &quot;onMMKVFileLengthError&quot;, &quot;(Ljava/lang/String;)I&quot;);</span><br><span class="line">    if (!g_callbackOnFileLengthErrorID) &#123;</span><br><span class="line">        MMKVError(&quot;fail to get method id for onMMKVFileLengthError&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    g_mmkvLogID =</span><br><span class="line">        env-&gt;GetStaticMethodID(g_cls, &quot;mmkvLogImp&quot;, &quot;(ILjava/lang/String;ILjava/lang/String;Ljava/lang/String;)V&quot;);</span><br><span class="line">    if (!g_mmkvLogID) &#123;</span><br><span class="line">        MMKVError(&quot;fail to get method id for mmkvLogImp&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    g_callbackOnContentChange =</span><br><span class="line">        env-&gt;GetStaticMethodID(g_cls, &quot;onContentChangedByOuterProcess&quot;, &quot;(Ljava/lang/String;)V&quot;);</span><br><span class="line">    if (!g_callbackOnContentChange) &#123;</span><br><span class="line">        MMKVError(&quot;fail to get method id for onContentChangedByOuterProcess()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // get current API level by accessing android.os.Build.VERSION.SDK_INT</span><br><span class="line">    jclass versionClass = env-&gt;FindClass(&quot;android/os/Build$VERSION&quot;);</span><br><span class="line">    if (versionClass) &#123;</span><br><span class="line">        jfieldID sdkIntFieldID = env-&gt;GetStaticFieldID(versionClass, &quot;SDK_INT&quot;, &quot;I&quot;);</span><br><span class="line">        if (sdkIntFieldID) &#123;</span><br><span class="line">            g_android_api = env-&gt;GetStaticIntField(versionClass, sdkIntFieldID);</span><br><span class="line">            MMKVInfo(&quot;current API level = %d&quot;, g_android_api);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            MMKVError(&quot;fail to get field id android.os.Build.VERSION.SDK_INT&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        MMKVError(&quot;fail to get class android.os.Build.VERSION&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // get CPU status of ARMv8 extensions (CRC32, AES)</span><br><span class="line">#ifdef __aarch64__</span><br><span class="line">    auto hwcaps = getauxval(AT_HWCAP);</span><br><span class="line">    if (hwcaps &amp; HWCAP_AES) &#123;</span><br><span class="line">        AES_set_encrypt_key = openssl_aes_armv8_set_encrypt_key;</span><br><span class="line">        AES_encrypt = openssl_aes_armv8_encrypt;</span><br><span class="line">        MMKVInfo(&quot;armv8 AES instructions is supported&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (hwcaps &amp; HWCAP_CRC32) &#123;</span><br><span class="line">        CRC32 = mmkv::armv8_crc32;</span><br><span class="line">        MMKVInfo(&quot;armv8 CRC32 instructions is supported&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上这里面做的事情十分简单：</p>
<ol>
<li><p>注册MMKV类在jni的反射对象，以及MMKV的java层对应的native方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod g_methods[] = &#123;</span><br><span class="line">    &#123;&quot;onExit&quot;, &quot;()V&quot;, (void *) mmkv::onExit&#125;,</span><br><span class="line">    &#123;&quot;cryptKey&quot;, &quot;()Ljava/lang/String;&quot;, (void *) mmkv::cryptKey&#125;,</span><br><span class="line">    &#123;&quot;reKey&quot;, &quot;(Ljava/lang/String;)Z&quot;, (void *) mmkv::reKey&#125;,</span><br><span class="line">    &#123;&quot;checkReSetCryptKey&quot;, &quot;(Ljava/lang/String;)V&quot;, (void *) mmkv::checkReSetCryptKey&#125;,</span><br><span class="line">    &#123;&quot;pageSize&quot;, &quot;()I&quot;, (void *) mmkv::pageSize&#125;,</span><br><span class="line">    &#123;&quot;mmapID&quot;, &quot;()Ljava/lang/String;&quot;, (void *) mmkv::mmapID&#125;,</span><br><span class="line">    &#123;&quot;lock&quot;, &quot;()V&quot;, (void *) mmkv::lock&#125;,</span><br><span class="line">    &#123;&quot;unlock&quot;, &quot;()V&quot;, (void *) mmkv::unlock&#125;,</span><br><span class="line">    &#123;&quot;tryLock&quot;, &quot;()Z&quot;, (void *) mmkv::tryLock&#125;,</span><br><span class="line">    &#123;&quot;allKeys&quot;, &quot;()[Ljava/lang/String;&quot;, (void *) mmkv::allKeys&#125;,</span><br><span class="line">    &#123;&quot;removeValuesForKeys&quot;, &quot;([Ljava/lang/String;)V&quot;, (void *) mmkv::removeValuesForKeys&#125;,</span><br><span class="line">    &#123;&quot;clearAll&quot;, &quot;()V&quot;, (void *) mmkv::clearAll&#125;,</span><br><span class="line">    &#123;&quot;trim&quot;, &quot;()V&quot;, (void *) mmkv::trim&#125;,</span><br><span class="line">    &#123;&quot;close&quot;, &quot;()V&quot;, (void *) mmkv::close&#125;,</span><br><span class="line">    &#123;&quot;clearMemoryCache&quot;, &quot;()V&quot;, (void *) mmkv::clearMemoryCache&#125;,</span><br><span class="line">    &#123;&quot;sync&quot;, &quot;(Z)V&quot;, (void *) mmkv::sync&#125;,</span><br><span class="line">    &#123;&quot;isFileValid&quot;, &quot;(Ljava/lang/String;)Z&quot;, (void *) mmkv::isFileValid&#125;,</span><br><span class="line">    &#123;&quot;ashmemFD&quot;, &quot;()I&quot;, (void *) mmkv::ashmemFD&#125;,</span><br><span class="line">    &#123;&quot;ashmemMetaFD&quot;, &quot;()I&quot;, (void *) mmkv::ashmemMetaFD&#125;,</span><br><span class="line">    &#123;&quot;jniInitialize&quot;, &quot;(Ljava/lang/String;I)V&quot;, (void *) mmkv::jniInitialize&#125;,</span><br><span class="line">    &#123;&quot;getMMKVWithID&quot;, &quot;(Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;)J&quot;, (void *) mmkv::getMMKVWithID&#125;,</span><br><span class="line">    &#123;&quot;getMMKVWithIDAndSize&quot;, &quot;(Ljava/lang/String;IILjava/lang/String;)J&quot;, (void *) mmkv::getMMKVWithIDAndSize&#125;,</span><br><span class="line">    &#123;&quot;getDefaultMMKV&quot;, &quot;(ILjava/lang/String;)J&quot;, (void *) mmkv::getDefaultMMKV&#125;,</span><br><span class="line">    &#123;&quot;getMMKVWithAshmemFD&quot;, &quot;(Ljava/lang/String;IILjava/lang/String;)J&quot;, (void *) mmkv::getMMKVWithAshmemFD&#125;,</span><br><span class="line">    &#123;&quot;encodeBool&quot;, &quot;(JLjava/lang/String;Z)Z&quot;, (void *) mmkv::encodeBool&#125;,</span><br><span class="line">    &#123;&quot;decodeBool&quot;, &quot;(JLjava/lang/String;Z)Z&quot;, (void *) mmkv::decodeBool&#125;,</span><br><span class="line">    &#123;&quot;encodeInt&quot;, &quot;(JLjava/lang/String;I)Z&quot;, (void *) mmkv::encodeInt&#125;,</span><br><span class="line">    &#123;&quot;decodeInt&quot;, &quot;(JLjava/lang/String;I)I&quot;, (void *) mmkv::decodeInt&#125;,</span><br><span class="line">    &#123;&quot;encodeLong&quot;, &quot;(JLjava/lang/String;J)Z&quot;, (void *) mmkv::encodeLong&#125;,</span><br><span class="line">    &#123;&quot;decodeLong&quot;, &quot;(JLjava/lang/String;J)J&quot;, (void *) mmkv::decodeLong&#125;,</span><br><span class="line">    &#123;&quot;encodeFloat&quot;, &quot;(JLjava/lang/String;F)Z&quot;, (void *) mmkv::encodeFloat&#125;,</span><br><span class="line">    &#123;&quot;decodeFloat&quot;, &quot;(JLjava/lang/String;F)F&quot;, (void *) mmkv::decodeFloat&#125;,</span><br><span class="line">    &#123;&quot;encodeDouble&quot;, &quot;(JLjava/lang/String;D)Z&quot;, (void *) mmkv::encodeDouble&#125;,</span><br><span class="line">    &#123;&quot;decodeDouble&quot;, &quot;(JLjava/lang/String;D)D&quot;, (void *) mmkv::decodeDouble&#125;,</span><br><span class="line">    &#123;&quot;encodeString&quot;, &quot;(JLjava/lang/String;Ljava/lang/String;)Z&quot;, (void *) mmkv::encodeString&#125;,</span><br><span class="line">    &#123;&quot;decodeString&quot;, &quot;(JLjava/lang/String;Ljava/lang/String;)Ljava/lang/String;&quot;, (void *) mmkv::decodeString&#125;,</span><br><span class="line">    &#123;&quot;encodeSet&quot;, &quot;(JLjava/lang/String;[Ljava/lang/String;)Z&quot;, (void *) mmkv::encodeSet&#125;,</span><br><span class="line">    &#123;&quot;decodeStringSet&quot;, &quot;(JLjava/lang/String;)[Ljava/lang/String;&quot;, (void *) mmkv::decodeStringSet&#125;,</span><br><span class="line">    &#123;&quot;encodeBytes&quot;, &quot;(JLjava/lang/String;[B)Z&quot;, (void *) mmkv::encodeBytes&#125;,</span><br><span class="line">    &#123;&quot;decodeBytes&quot;, &quot;(JLjava/lang/String;)[B&quot;, (void *) mmkv::decodeBytes&#125;,</span><br><span class="line">    &#123;&quot;containsKey&quot;, &quot;(JLjava/lang/String;)Z&quot;, (void *) mmkv::containsKey&#125;,</span><br><span class="line">    &#123;&quot;count&quot;, &quot;(J)J&quot;, (void *) mmkv::count&#125;,</span><br><span class="line">    &#123;&quot;totalSize&quot;, &quot;(J)J&quot;, (void *) mmkv::totalSize&#125;,</span><br><span class="line">    &#123;&quot;removeValueForKey&quot;, &quot;(JLjava/lang/String;)V&quot;, (void *) mmkv::removeValueForKey&#125;,</span><br><span class="line">    &#123;&quot;valueSize&quot;, &quot;(JLjava/lang/String;Z)I&quot;, (void *) mmkv::valueSize&#125;,</span><br><span class="line">    &#123;&quot;setLogLevel&quot;, &quot;(I)V&quot;, (void *) mmkv::setLogLevel&#125;,</span><br><span class="line">    &#123;&quot;setCallbackHandler&quot;, &quot;(ZZ)V&quot;, (void *) mmkv::setCallbackHandler&#125;,</span><br><span class="line">    &#123;&quot;createNB&quot;, &quot;(I)J&quot;, (void *) mmkv::createNB&#125;,</span><br><span class="line">    &#123;&quot;destroyNB&quot;, &quot;(JI)V&quot;, (void *) mmkv::destroyNB&#125;,</span><br><span class="line">    &#123;&quot;writeValueToNB&quot;, &quot;(JLjava/lang/String;JI)I&quot;, (void *) mmkv::writeValueToNB&#125;,</span><br><span class="line">    &#123;&quot;setWantsContentChangeNotify&quot;, &quot;(Z)V&quot;, (void *) mmkv::setWantsContentChangeNotify&#125;,</span><br><span class="line">    &#123;&quot;checkContentChangedByOuterProcess&quot;, &quot;()V&quot;, (void *) mmkv::checkContentChanged&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int registerNativeMethods(JNIEnv *env, jclass cls) &#123;</span><br><span class="line">    return env-&gt;RegisterNatives(cls, g_methods, sizeof(g_methods) / sizeof(g_methods[0]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能从这些native方法中看到了所有MMKV的存储方法，设置支持共享内存ashemem的存储，支持直接获取native malloc申请的内存</p>
</li>
<li><p>获取当前编译的版本号并且记录下来。</p>
</li>
</ol>
<h3><span id="mmkv-jniinitialize">MMKV jniInitialize</span></h3><p>接下来就是MMKV正式的初始化方法了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">MMKV_JNI void jniInitialize(JNIEnv *env, jobject obj, jstring rootDir, jint logLevel) &#123;</span><br><span class="line">    if (!rootDir) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    const char *kstr = env-&gt;GetStringUTFChars(rootDir, nullptr);</span><br><span class="line">    if (kstr) &#123;</span><br><span class="line">        MMKV::initializeMMKV(kstr, (MMKVLogLevel) logLevel);</span><br><span class="line">        env-&gt;ReleaseStringUTFChars(rootDir, kstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void initialize() &#123;</span><br><span class="line">    g_instanceDic = new unordered_map&lt;string, MMKV *&gt;;</span><br><span class="line">    g_instanceLock = new ThreadLock();</span><br><span class="line">    g_instanceLock-&gt;initialize();</span><br><span class="line"></span><br><span class="line">    mmkv::DEFAULT_MMAP_SIZE = mmkv::getPageSize();</span><br><span class="line">    MMKVInfo(&quot;page size:%d&quot;, DEFAULT_MMAP_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadOnceToken_t once_control = ThreadOnceUninitialized;</span><br><span class="line"></span><br><span class="line">void MMKV::initializeMMKV(const MMKVPath_t &amp;rootDir, MMKVLogLevel logLevel) &#123;</span><br><span class="line">    g_currentLogLevel = logLevel;</span><br><span class="line"></span><br><span class="line">    ThreadLock::ThreadOnce(&amp;once_control, initialize);</span><br><span class="line"></span><br><span class="line">    g_rootDir = rootDir;</span><br><span class="line">    mkPath(g_rootDir);</span><br><span class="line"></span><br><span class="line">    MMKVInfo(&quot;root dir: &quot; MMKV_PATH_FORMAT, g_rootDir.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获取rootDir的url char指针数组字符串，调用MMKV::initializeMMKV进一步初始化。</li>
<li>调用ThreadLock::ThreadOnce调用方法指针initialize进行初始化。在方法指针initialize中，则是初始化了一个全局的线程锁ThreadLock。以及一个全局的散列表g_instanceDic。在MMKV中，设置好每一页(page)的大小，一般来说我们在32位的机子中一页都是4kb大小。设置一个全局的打印对象g_currentLogLevel。<br>这个方法实际上调用的是pthread_once方法。它一般是在多线程环境中，根据内核的调度策略，选择一个线程初始化一次的方法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadLock::ThreadLock() &#123;</span><br><span class="line">    pthread_mutexattr_t attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;m_lock, &amp;attr);</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>mkPath根据路径创建文件夹<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">extern bool mkPath(const MMKVPath_t &amp;str) &#123;</span><br><span class="line">    char *path = strdup(str.c_str());</span><br><span class="line"></span><br><span class="line">    struct stat sb = &#123;&#125;;</span><br><span class="line">    bool done = false;</span><br><span class="line">    char *slash = path;</span><br><span class="line"></span><br><span class="line">    while (!done) &#123;</span><br><span class="line">        slash += strspn(slash, &quot;/&quot;);</span><br><span class="line">        slash += strcspn(slash, &quot;/&quot;);</span><br><span class="line"></span><br><span class="line">        done = (*slash == &#x27;\0&#x27;);</span><br><span class="line">        *slash = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line">        if (stat(path, &amp;sb) != 0) &#123;</span><br><span class="line">            if (errno != ENOENT || mkdir(path, 0777) != 0) &#123;</span><br><span class="line">                MMKVWarning(&quot;%s : %s&quot;, path, strerror(errno));</span><br><span class="line">                free(path);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (!S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">            MMKVWarning(&quot;%s: %s&quot;, path, strerror(ENOTDIR));</span><br><span class="line">            free(path);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *slash = &#x27;/&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    free(path);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其实这里面的算法很简单：</li>
<li>strdup拷贝一份字符串到path中。</li>
<li>strspn 是一直找到匹配字符串，直到出现第一个不是”&#x2F;“</li>
<li>strcspn 则是一直找不匹配的字符串，直到出现第一个“&#x2F;”<br>经过这样拆解，就能把路径一个个分割开。通过这中方式就能直到什么时候遍历完整个路径。</li>
<li>stat获取path每一个文件夹的权限状态，必须保证每一级别的文件都是0777，也就是读写执行全部权限打开。</li>
</ol>
<h2><span id="mmkv-的实例化-defaultmmkv与mmkvwithid">MMKV 的实例化 defaultMMKV与mmkvWithID</span></h2><p>MMKV java层的实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static MMKV defaultMMKV() &#123;</span><br><span class="line">    if (rootDir == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;You should Call MMKV.initialize() first.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long handle = getDefaultMMKV(SINGLE_PROCESS_MODE, null);</span><br><span class="line">    return new MMKV(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>defaultMMKV此时调用的是getDefaultMMKV这个native方法，默认是单进程模式。从这里的设计都能猜到getDefaultMMKV会从native层实例化一个MMKV对象，并且让实例化好的Java层MMKV对象持有。之后Java层的方法和native层的方法一一映射就能实现一个直接操作native对象的Java对象。</p>
<p>我们再来看看MMKV的mmkvWithID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static MMKV mmkvWithID(String mmapID) &#123;</span><br><span class="line">    if (rootDir == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;You should Call MMKV.initialize() first.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long handle = getMMKVWithID(mmapID, SINGLE_PROCESS_MODE, null, null);</span><br><span class="line">    return new MMKV(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉上和defaultMMKV有点相似，也是调用native层方法进行初始化，并且让java层MMKV对象持有native层。那么我们可否认为这两个实例化本质上在底层调用同一个方法，只是多了一个id设置呢？</p>
<p>MMKV native层实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MMKV_JNI jlong getDefaultMMKV(JNIEnv *env, jobject obj, jint mode, jstring cryptKey) &#123;</span><br><span class="line">    MMKV *kv = nullptr;</span><br><span class="line"></span><br><span class="line">    if (cryptKey) &#123;</span><br><span class="line">        string crypt = jstring2string(env, cryptKey);</span><br><span class="line">        if (crypt.length() &gt; 0) &#123;</span><br><span class="line">            kv = MMKV::defaultMMKV((MMKVMode) mode, &amp;crypt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!kv) &#123;</span><br><span class="line">        kv = MMKV::defaultMMKV((MMKVMode) mode, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (jlong) kv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define DEFAULT_MMAP_ID &quot;mmkv.default&quot;</span><br><span class="line"></span><br><span class="line">MMKV *MMKV::defaultMMKV(MMKVMode mode, string *cryptKey) &#123;</span><br><span class="line">#ifndef MMKV_ANDROID</span><br><span class="line">    return mmkvWithID(DEFAULT_MMAP_ID, mode, cryptKey);</span><br><span class="line">#else</span><br><span class="line">    return mmkvWithID(DEFAULT_MMAP_ID, DEFAULT_MMAP_SIZE, mode, cryptKey);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看看MMKV.h文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static MMKV *mmkvWithID(const std::string &amp;mmapID,</span><br><span class="line">                        int size = mmkv::DEFAULT_MMAP_SIZE,</span><br><span class="line">                        MMKVMode mode = MMKV_SINGLE_PROCESS,</span><br><span class="line">                        std::string *cryptKey = nullptr,</span><br><span class="line">                        MMKVPath_t *relativePath = nullptr);</span><br></pre></td></tr></table></figure>
<p>这里就能看到上面的推测是正确的，只要是实例化，最后都是调用mmkvWithID进行实例化。默认的mmkv的id就是mmkv.default。Android端则会设置一个默认的page大小,假设4kb为例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#    define string2MMKVPath_t(str) (str)</span><br><span class="line"></span><br><span class="line">string mmapedKVKey(const string &amp;mmapID, MMKVPath_t *relativePath) &#123;</span><br><span class="line">    if (relativePath &amp;&amp; g_rootDir != (*relativePath)) &#123;</span><br><span class="line">        return md5(*relativePath + MMKV_PATH_SLASH + string2MMKVPath_t(mmapID));</span><br><span class="line">    &#125;</span><br><span class="line">    return mmapID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MMKV *MMKV::mmkvWithID(const string &amp;mmapID, int size, MMKVMode mode, string *cryptKey, string *relativePath) &#123;</span><br><span class="line"></span><br><span class="line">    if (mmapID.empty()) &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPED_LOCK(g_instanceLock);</span><br><span class="line"></span><br><span class="line">    auto mmapKey = mmapedKVKey(mmapID, relativePath);</span><br><span class="line">    auto itr = g_instanceDic-&gt;find(mmapKey);</span><br><span class="line">    if (itr != g_instanceDic-&gt;end()) &#123;</span><br><span class="line">        MMKV *kv = itr-&gt;second;</span><br><span class="line">        return kv;</span><br><span class="line">    &#125;</span><br><span class="line">    if (relativePath) &#123;</span><br><span class="line">        if (!isFileExist(*relativePath)) &#123;</span><br><span class="line">            if (!mkPath(*relativePath)) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MMKVInfo(&quot;prepare to load %s (id %s) from relativePath %s&quot;, mmapID.c_str(), mmapKey.c_str(),</span><br><span class="line">                 relativePath-&gt;c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    auto kv = new MMKV(mmapID, size, mode, cryptKey, relativePath);</span><br><span class="line">    (*g_instanceDic)[mmapKey] = kv;</span><br><span class="line">    return kv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的mmkvID以及对应的MMKV实例都会保存在之前实例化的g_instanceDic散列表中。其中mmkv每一个id对应一个文件的路径，其中路径是这么处理的：</p>
<p>相对路径(android中是 data&#x2F;data&#x2F;包名&#x2F;files&#x2F;mmkv) + &#x2F; + mmkvID</p>
<p>如果发现对应路径下的mmkv在散列表中已经缓存了，则直接返回。否则就会把相对路径保存下来，传递给MMKV进行实例化，并保存在g_instanceDic散列表中。</p>
<h2><span id="mmkv-的构造函数">MMKV 的构造函数</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">MMKV::MMKV(const string &amp;mmapID, int size, MMKVMode mode, string *cryptKey, string *relativePath)</span><br><span class="line">    : m_mmapID(mmapedKVKey(mmapID, relativePath)) // historically Android mistakenly use mmapKey as mmapID</span><br><span class="line">    , m_path(mappedKVPathWithID(m_mmapID, mode, relativePath))</span><br><span class="line">    , m_crcPath(crcPathWithID(m_mmapID, mode, relativePath))</span><br><span class="line">    , m_file(new MemoryFile(m_path, size, (mode &amp; MMKV_ASHMEM) ? MMFILE_TYPE_ASHMEM : MMFILE_TYPE_FILE))</span><br><span class="line">    , m_metaFile(new MemoryFile(m_crcPath, DEFAULT_MMAP_SIZE, m_file-&gt;m_fileType))</span><br><span class="line">    , m_metaInfo(new MMKVMetaInfo())</span><br><span class="line">    , m_crypter(nullptr)</span><br><span class="line">    , m_lock(new ThreadLock())</span><br><span class="line">    , m_fileLock(new FileLock(m_metaFile-&gt;getFd(), (mode &amp; MMKV_ASHMEM)))</span><br><span class="line">    , m_sharedProcessLock(new InterProcessLock(m_fileLock, SharedLockType))</span><br><span class="line">    , m_exclusiveProcessLock(new InterProcessLock(m_fileLock, ExclusiveLockType))</span><br><span class="line">    , m_isInterProcess((mode &amp; MMKV_MULTI_PROCESS) != 0 || (mode &amp; CONTEXT_MODE_MULTI_PROCESS) != 0) &#123;</span><br><span class="line">    m_actualSize = 0;</span><br><span class="line">    m_output = nullptr;</span><br><span class="line"></span><br><span class="line">    if (cryptKey &amp;&amp; cryptKey-&gt;length() &gt; 0) &#123;</span><br><span class="line">        m_crypter = new AESCrypt(cryptKey-&gt;data(), cryptKey-&gt;length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_needLoadFromFile = true;</span><br><span class="line">    m_hasFullWriteback = false;</span><br><span class="line"></span><br><span class="line">    m_crcDigest = 0;</span><br><span class="line"></span><br><span class="line">    m_sharedProcessLock-&gt;m_enable = m_isInterProcess;</span><br><span class="line">    m_exclusiveProcessLock-&gt;m_enable = m_isInterProcess;</span><br><span class="line"></span><br><span class="line">    // sensitive zone</span><br><span class="line">    &#123;</span><br><span class="line">        SCOPED_LOCK(m_sharedProcessLock);</span><br><span class="line">        loadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看MMKV构造函数中几个关键的字段是怎么初始化。</p>
<ol>
<li><p>m_mmapID MMKV的ID通过mmapedKVKey创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string mmapedKVKey(const string &amp;mmapID, MMKVPath_t *relativePath) &#123;</span><br><span class="line">    if (relativePath &amp;&amp; g_rootDir != (*relativePath)) &#123;</span><br><span class="line">        return md5(*relativePath + MMKV_PATH_SLASH + string2MMKVPath_t(mmapID));</span><br><span class="line">    &#125;</span><br><span class="line">    return mmapID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mmkvID就是经过md5后对应缓存文件对应的路径。</p>
</li>
<li><p>m_path mmkv 缓存的路径通过mappedKVPathWithID生成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MMKVPath_t mappedKVPathWithID(const string &amp;mmapID, MMKVMode mode, MMKVPath_t *relativePath) &#123;</span><br><span class="line">#ifndef MMKV_ANDROID</span><br><span class="line">...</span><br><span class="line">#else</span><br><span class="line">    if (mode &amp; MMKV_ASHMEM) &#123;</span><br><span class="line">        return ashmemMMKVPathWithID(encodeFilePath(mmapID));</span><br><span class="line">    &#125; else if (relativePath) &#123;</span><br><span class="line">#endif</span><br><span class="line">        return *relativePath + MMKV_PATH_SLASH + encodeFilePath(mmapID);</span><br><span class="line">    &#125;</span><br><span class="line">    return g_rootDir + MMKV_PATH_SLASH + encodeFilePath(mmapID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能看到这里是根据当前的mode初始化id，如果不是ashmem匿名共享内存模式进行创建，则会和上面的处理类似。id就是经过md5后对应缓存文件对应的路径。</p>
</li>
</ol>
<p>注意这里mode设置的是MMKV_ASHMEM，也就是ashmem匿名共享内存模式则是如下创建方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constexpr char ASHMEM_NAME_DEF[] = &quot;/dev/ashmem&quot;;</span><br><span class="line"></span><br><span class="line">MMKVPath_t ashmemMMKVPathWithID(const MMKVPath_t &amp;mmapID) &#123;</span><br><span class="line">    return MMKVPath_t(ASHMEM_NAME_DEF) + MMKV_PATH_SLASH + mmapID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上就是在驱动目录下的一个内存文件地址。</p>
<ol start="3">
<li>m_crcPath 一个.crc文件的路径。这个crc文件实际上用于保存crc数据校验key，避免出现传输异常的数据进行保存了。</li>
<li>m_file 一个依据m_path构建的内存文件MemoryFile对象。</li>
<li>m_metaFile 一个依据m_crcPath构建的内存文件MemoryFile对象。</li>
<li>m_metaInfo 一个MMKVMetaInfo结构体，这个结构体一般是读写的时候，带上的MMKV的版本信息，映射的内存大小，加密crc的key等。</li>
<li>m_crypter 默认是一个AESCrypt 对称加密器</li>
<li>m_lock ThreadLock线程锁</li>
<li>m_fileLock 一个以m_metaFile的fd 文件锁</li>
<li>m_sharedProcessLock 类型是InterProcessLock，这是一种文件共享锁</li>
<li>m_exclusiveProcessLock 类型是InterProcessLock，这是一种排他锁</li>
<li>m_isInterProcess 判断是否打开了多进程模式的标志位，一旦关闭了，所有进程锁都会失效。<br>接下来，在构造函数中使用了共享的文件锁进行保护后，调用loadFromFile进一步的初始化MMKV内部的数据。</li>
</ol>
<p>我们大致的了解MMKV中每一个字段的负责的职责，但是具体如何进行工作下文都会解析。</p>
<p>在这里面我们遇到了看起来十分核心的类MemoryFile，它的名字有点像Ashmem匿名共享内存一文中描述过Java层的映射的匿名内存文件。</p>
<p>我们先来看看MemoryFile的初始化。</p>
<h2><span id="memoryfile的初始化">MemoryFile的初始化</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">constexpr char ASHMEM_NAME_DEF[] = &quot;/dev/ashmem&quot;;</span><br><span class="line"></span><br><span class="line">MemoryFile::MemoryFile(const string &amp;path, size_t size, FileType fileType)</span><br><span class="line">    : m_name(path), m_fd(-1), m_ptr(nullptr), m_size(0), m_fileType(fileType) &#123;</span><br><span class="line">    if (m_fileType == MMFILE_TYPE_FILE) &#123;</span><br><span class="line">        reloadFromFile();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // round up to (n * pagesize)</span><br><span class="line">        if (size &lt; DEFAULT_MMAP_SIZE || (size % DEFAULT_MMAP_SIZE != 0)) &#123;</span><br><span class="line">            size = ((size / DEFAULT_MMAP_SIZE) + 1) * DEFAULT_MMAP_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        auto filename = m_name.c_str();</span><br><span class="line">        auto ptr = strstr(filename, ASHMEM_NAME_DEF);</span><br><span class="line">        if (ptr &amp;&amp; ptr[sizeof(ASHMEM_NAME_DEF) - 1] == &#x27;/&#x27;) &#123;</span><br><span class="line">            filename = ptr + sizeof(ASHMEM_NAME_DEF);</span><br><span class="line">        &#125;</span><br><span class="line">        m_fd = ASharedMemory_create(filename, size);</span><br><span class="line">        if (m_fd &gt;= 0) &#123;</span><br><span class="line">            m_size = size;</span><br><span class="line">            auto ret = mmap();</span><br><span class="line">            if (!ret) &#123;</span><br><span class="line">                doCleanMemoryCache(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MemeoryFile分为两个模式进行初始化：</p>
<ol>
<li>按照普通的内存文件进行映射到内存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void MemoryFile::reloadFromFile() &#123;</span><br><span class="line">...</span><br><span class="line">    m_fd = open(m_name.c_str(), O_RDWR | O_CREAT | O_CLOEXEC, S_IRWXU);</span><br><span class="line">    if (m_fd &lt; 0) &#123;</span><br><span class="line">        MMKVError(&quot;fail to open:%s, %s&quot;, m_name.c_str(), strerror(errno));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        FileLock fileLock(m_fd);</span><br><span class="line">        InterProcessLock lock(&amp;fileLock, ExclusiveLockType);</span><br><span class="line">        SCOPED_LOCK(&amp;lock);</span><br><span class="line"></span><br><span class="line">        mmkv::getFileSize(m_fd, m_size);</span><br><span class="line">        // round up to (n * pagesize)</span><br><span class="line">        if (m_size &lt; DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != 0)) &#123;</span><br><span class="line">            size_t roundSize = ((m_size / DEFAULT_MMAP_SIZE) + 1) * DEFAULT_MMAP_SIZE;</span><br><span class="line">            truncate(roundSize);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            auto ret = mmap();</span><br><span class="line">            if (!ret) &#123;</span><br><span class="line">                doCleanMemoryCache(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里的处理很简单：</li>
</ol>
<ul>
<li>1)首先尝试的打开该路径下file文件,如果fd小于0，说明file没有真正的创建过，则会调用mmap方法在内存中进行映射对应大小的内存。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool MemoryFile::mmap() &#123;</span><br><span class="line">    m_ptr = (char *) ::mmap(m_ptr, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, 0);</span><br><span class="line">    if (m_ptr == MAP_FAILED) &#123;</span><br><span class="line">        MMKVError(&quot;fail to mmap [%s], %s&quot;, m_name.c_str(), strerror(errno));</span><br><span class="line">        m_ptr = nullptr;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
能看到此时将会调用mmap系统调用，通过设置标志位可读写，MAP_SHARED的模式进行打开。这样就file就在在内核中映射了一段4kb内存，以后访问文件可以不经过内核，直接访问file映射的这一段内存。</li>
</ul>
<p>关于mmap系统调用的源码解析可以看这一篇Binder驱动的初始化 映射原理。</p>
<ul>
<li>2)如果此时对应的内存文件已经映射过了，将会检测其大小是否是为0，或者是不是刚好是4kb的倍数。如果不是，则找到当前大小最近的4kb倍数同感ftruncate系统调用进行扩容。这样就能保证mmap映射的数据是整齐的页的倍数。这么做就能有效的减少内存碎片。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">bool MemoryFile::truncate(size_t size) &#123;</span><br><span class="line">...</span><br><span class="line">    auto oldSize = m_size;</span><br><span class="line">    m_size = size;</span><br><span class="line">    // round up to (n * pagesize)</span><br><span class="line">    if (m_size &lt; DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != 0)) &#123;</span><br><span class="line">        m_size = ((m_size / DEFAULT_MMAP_SIZE) + 1) * DEFAULT_MMAP_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (::ftruncate(m_fd, static_cast&lt;off_t&gt;(m_size)) != 0) &#123;</span><br><span class="line">        MMKVError(&quot;fail to truncate [%s] to size %zu, %s&quot;, m_name.c_str(), m_size, strerror(errno));</span><br><span class="line">        m_size = oldSize;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (m_size &gt; oldSize) &#123;</span><br><span class="line">        if (!zeroFillFile(m_fd, oldSize, m_size - oldSize)) &#123;</span><br><span class="line">            MMKVError(&quot;fail to zeroFile [%s] to size %zu, %s&quot;, m_name.c_str(), m_size, strerror(errno));</span><br><span class="line">            m_size = oldSize;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (m_ptr) &#123;</span><br><span class="line">        if (munmap(m_ptr, oldSize) != 0) &#123;</span><br><span class="line">            MMKVError(&quot;fail to munmap [%s], %s&quot;, m_name.c_str(), strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    auto ret = mmap();</span><br><span class="line">    if (!ret) &#123;</span><br><span class="line">        doCleanMemoryCache(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
能看到在这个过程中实际上还是通过ftruncate进行扩容，接着调用zeroFillFile，先通过lseek把指针移动当前容量的最后，并把剩余的部分都填充空数据’\0’。最后映射指向的地址是有效的，会先解开后重新进行映射。</li>
</ul>
<p>为什么要做最后这个步骤呢？如果阅读过我解析的mmap的源码一文，实际上就能明白，file使用MAP_SHARED的模式本质上是给file结构体绑定一段vma映射好的内存。ftruncate只是给file结构体进行了扩容，但是还没有对对应绑定虚拟内存进行扩容，因此需要解开一次映射后，重新mmap一次。</p>
<ol start="2">
<li>通过Ashmem驱动映射一段共享匿名内存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int ASharedMemory_create(const char *name, size_t size) &#123;</span><br><span class="line">    int fd = -1;</span><br><span class="line">    if (g_android_api &gt;= __ANDROID_API_O__) &#123;</span><br><span class="line">        static auto handle = loadLibrary();</span><br><span class="line">        static AShmem_create_t funcPtr =</span><br><span class="line">            (handle != nullptr) ? reinterpret_cast&lt;AShmem_create_t&gt;(dlsym(handle, &quot;ASharedMemory_create&quot;)) : nullptr;</span><br><span class="line">        if (funcPtr) &#123;</span><br><span class="line">            fd = funcPtr(name, size);</span><br><span class="line">            if (fd &lt; 0) &#123;</span><br><span class="line">                MMKVError(&quot;fail to ASharedMemory_create %s with size %zu, errno:%s&quot;, name, size, strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            MMKVWarning(&quot;fail to locate ASharedMemory_create() from loading libandroid.so&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        fd = open(ASHMEM_NAME_DEF, O_RDWR | O_CLOEXEC);</span><br><span class="line">        if (fd &lt; 0) &#123;</span><br><span class="line">            MMKVError(&quot;fail to open ashmem:%s, %s&quot;, name, strerror(errno));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (ioctl(fd, ASHMEM_SET_NAME, name) != 0) &#123;</span><br><span class="line">                MMKVError(&quot;fail to set ashmem name:%s, %s&quot;, name, strerror(errno));</span><br><span class="line">            &#125; else if (ioctl(fd, ASHMEM_SET_SIZE, size) != 0) &#123;</span><br><span class="line">                MMKVError(&quot;fail to set ashmem:%s, size %zu, %s&quot;, name, size, strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
MMKV在如果使用Ashmem模式打开：</li>
</ol>
<ul>
<li><p>1)如果大于Android O就会从libandroid.so中查找ASharedMemory_create 描述符也就是方法地址，直接通过这个方法通过ashmem创建一个映射在ashmem驱动的内存。Ashmem驱动的核心原理请看Ashmem匿名共享内存。</p>
</li>
<li><p>2)否则则使用我在Ashmem的文章所说，按照三个步骤进行Ashmem驱动的映射，首先open打开在Ashmem中的映射，接着使用ASHMEM_SET_NAME给匿名内存命名，最后调用ASHMEM_SET_SIZE设置需要在Ashmem中映射的内存大小。</p>
</li>
</ul>
<p>接下来loadFromFile 这个方法可以说是MMKV的核心方法，所有的读写，还是扩容都需要这个方法，从映射的文件内存，缓存到MMKV的内存中。</p>
<h2><span id="mmkv的初始化-loadfromfile">MMKV的初始化 loadFromFile</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">void MMKV::loadFromFile() &#123;</span><br><span class="line">    if (m_metaFile-&gt;isFileValid()) &#123;</span><br><span class="line">        m_metaInfo-&gt;read(m_metaFile-&gt;getMemory());</span><br><span class="line">    &#125;</span><br><span class="line">    if (m_crypter) &#123;</span><br><span class="line">        if (m_metaInfo-&gt;m_version &gt;= MMKVVersionRandomIV) &#123;</span><br><span class="line">            m_crypter-&gt;resetIV(m_metaInfo-&gt;m_vector, sizeof(m_metaInfo-&gt;m_vector));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!m_file-&gt;isFileValid()) &#123;</span><br><span class="line">        m_file-&gt;reloadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line">    if (!m_file-&gt;isFileValid()) &#123;</span><br><span class="line">        MMKVError(&quot;file [%s] not valid&quot;, m_path.c_str());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // error checking</span><br><span class="line">        bool loadFromFile = false, needFullWriteback = false;</span><br><span class="line">        checkDataValid(loadFromFile, needFullWriteback);</span><br><span class="line">...</span><br><span class="line">        auto ptr = (uint8_t *) m_file-&gt;getMemory();</span><br><span class="line">        // loading</span><br><span class="line">        if (loadFromFile &amp;&amp; m_actualSize &gt; 0) &#123;</span><br><span class="line">....</span><br><span class="line">            MMBuffer inputBuffer(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy);</span><br><span class="line">            if (m_crypter) &#123;</span><br><span class="line">                decryptBuffer(*m_crypter, inputBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">            clearDictionary(m_dic);</span><br><span class="line">            if (needFullWriteback) &#123;</span><br><span class="line">                MiniPBCoder::greedyDecodeMap(m_dic, inputBuffer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                MiniPBCoder::decodeMap(m_dic, inputBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">            m_output = new CodedOutputData(ptr + Fixed32Size, m_file-&gt;getFileSize() - Fixed32Size);</span><br><span class="line">            m_output-&gt;seek(m_actualSize);</span><br><span class="line">            if (needFullWriteback) &#123;</span><br><span class="line">                fullWriteback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // file not valid or empty, discard everything</span><br><span class="line">            SCOPED_LOCK(m_exclusiveProcessLock);</span><br><span class="line"></span><br><span class="line">            m_output = new CodedOutputData(ptr + Fixed32Size, m_file-&gt;getFileSize() - Fixed32Size);</span><br><span class="line">            if (m_actualSize &gt; 0) &#123;</span><br><span class="line">                writeActualSize(0, 0, nullptr, IncreaseSequence);</span><br><span class="line">                sync(MMKV_SYNC);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                writeActualSize(0, 0, nullptr, KeepSequence);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_needLoadFromFile = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入到这个方法后进行如下的处理：</p>
<ol>
<li>从m_metaFile内存文件中获取当前MMKV实例的配置保存到m_metaInfo 这个MMKVMetaInfo结构体中。由于是第一次实例化这个时候，内容全是空。稍微看看这个结构体的内容：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct MMKVMetaInfo &#123;</span><br><span class="line">    uint32_t m_crcDigest = 0; //crc校验的数据</span><br><span class="line">    uint32_t m_version = MMKVVersionSequence; //MMKV的状态MMKVVersionSequence = 1,</span><br><span class="line">    uint32_t m_sequence = 0; // full write-back count</span><br><span class="line">    unsigned char m_vector[AES_KEY_LEN] = &#123;&#125;;//aes的加密key</span><br><span class="line">    uint32_t m_actualSize = 0;//真实的大小</span><br><span class="line"></span><br><span class="line">    // confirmed info: it&#x27;s been synced to file</span><br><span class="line">    struct &#123;</span><br><span class="line">        uint32_t lastActualSize = 0;</span><br><span class="line">        uint32_t lastCRCDigest = 0;</span><br><span class="line">        uint32_t __reserved__[16] = &#123;&#125;;</span><br><span class="line">    &#125; m_lastConfirmedMetaInfo;//已经同步到文件的数据</span><br><span class="line"></span><br><span class="line">    void write(void *ptr) &#123;</span><br><span class="line">        MMKV_ASSERT(ptr);</span><br><span class="line">        memcpy(ptr, this, sizeof(MMKVMetaInfo));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void writeCRCAndActualSizeOnly(void *ptr) &#123;</span><br><span class="line">        MMKV_ASSERT(ptr);</span><br><span class="line">        auto other = (MMKVMetaInfo *) ptr;</span><br><span class="line">        other-&gt;m_crcDigest = m_crcDigest;</span><br><span class="line">        other-&gt;m_actualSize = m_actualSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void read(const void *ptr) &#123;</span><br><span class="line">        MMKV_ASSERT(ptr);</span><br><span class="line">        memcpy(this, ptr, sizeof(MMKVMetaInfo));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在这里，遇到了一个比较有歧义的字段m_version ，从名字看起来有点像MMKV的版本号。其实它指代的是MMKV当前的状态，由一个枚举对象代表：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum MMKVVersion : uint32_t &#123;</span><br><span class="line">    MMKVVersionDefault = 0,</span><br><span class="line"></span><br><span class="line">    // 记录当前MMKV的完整写回次数</span><br><span class="line">    MMKVVersionSequence = 1,</span><br><span class="line"></span><br><span class="line">    // 对随机数据进行加密存储</span><br><span class="line">    MMKVVersionRandomIV = 2,</span><br><span class="line"></span><br><span class="line">    // 保存了crc校验和存储存储大小，避免文件损坏</span><br><span class="line">    MMKVVersionActualSize = 3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>m_crypter不为空，则判断m_metaInfo中的m_version号是否大于等于2(MMKVVersionRandomIV)，是则调用resetIV方法进行aes加密的初始化。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constexpr size_t AES_KEY_LEN = 16;</span><br><span class="line">void AESCrypt::resetIV(const void *iv, size_t ivLength) &#123;</span><br><span class="line">    m_number = 0;</span><br><span class="line">    if (iv &amp;&amp; ivLength &gt; 0) &#123;</span><br><span class="line">        memcpy(m_vector, iv, (ivLength &gt; AES_KEY_LEN) ? AES_KEY_LEN : ivLength);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        memcpy(m_vector, m_key, AES_KEY_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意m_vector是一个长度16的char数组。其实很简单，就是把文件保存的m_vector获取16位拷贝到m_metaInfo的m_vector中。因为aes的加密必须以16的倍数才能正常运作。</li>
<li>m_file 真正工作的内存文件发现fd申请的有问题，就重新读取文件映射。</li>
<li>调用checkDataValid进行MMKV的初始化数据的检测。同时获取到两个标志位loadFromFile 代表是否从能从m_file中正常读取；needFullWriteback是否需要一口气完全写回到内存。</li>
<li>如果成功读取MemoryFile中的数据，且缓存的数据大小大于0.接下来将会获取内存文件中的数据保存到MMBuffer类中。并且调用AESCrypt的decryptBuffer解密MMBuffer中的内容。清空MMKV中存储键值对的m_dic散列表，并且从本地文件读取。</li>
<li>如果发现读取MemoryFile中的数据是空的，说明是第一次创建这个缓存文件，我们需要往m_metaFile写入当前MMKV的相关的信息。</li>
</ol>
<p>初始化分为这6点，我们从最后三点开始聊聊MMKV的初始化的核心逻辑。我们还需要开始关注MMKV中内存存储的结构。</p>
<h3><span id="checkdatavalid-校验mmkv数据有效性机制">checkDataValid 校验MMKV数据有效性机制</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">void MMKV::checkDataValid(bool &amp;loadFromFile, bool &amp;needFullWriteback) &#123;</span><br><span class="line">    // try auto recover from last confirmed location</span><br><span class="line">    auto fileSize = m_file-&gt;getFileSize();</span><br><span class="line">    auto checkLastConfirmedInfo = [&amp;] &#123;</span><br><span class="line">        if (m_metaInfo-&gt;m_version &gt;= MMKVVersionActualSize) &#123;</span><br><span class="line">            // downgrade &amp; upgrade support</span><br><span class="line">            uint32_t oldStyleActualSize = 0;</span><br><span class="line">            memcpy(&amp;oldStyleActualSize, m_file-&gt;getMemory(), Fixed32Size);</span><br><span class="line">            if (oldStyleActualSize != m_actualSize) &#123;</span><br><span class="line">...</span><br><span class="line">                if (oldStyleActualSize &lt; fileSize &amp;&amp; (oldStyleActualSize + Fixed32Size) &lt;= fileSize) &#123;</span><br><span class="line">                    if (checkFileCRCValid(oldStyleActualSize, m_metaInfo-&gt;m_crcDigest)) &#123;</span><br><span class="line">...</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            auto lastActualSize = m_metaInfo-&gt;m_lastConfirmedMetaInfo.lastActualSize;</span><br><span class="line">            if (lastActualSize &lt; fileSize &amp;&amp; (lastActualSize + Fixed32Size) &lt;= fileSize) &#123;</span><br><span class="line">                auto lastCRCDigest = m_metaInfo-&gt;m_lastConfirmedMetaInfo.lastCRCDigest;</span><br><span class="line">                if (checkFileCRCValid(lastActualSize, lastCRCDigest)) &#123;</span><br><span class="line">                    loadFromFile = true;</span><br><span class="line">                    writeActualSize(lastActualSize, lastCRCDigest, nullptr, KeepSequence);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               ....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    m_actualSize = readActualSize();</span><br><span class="line"></span><br><span class="line">    if (m_actualSize &lt; fileSize &amp;&amp; (m_actualSize + Fixed32Size) &lt;= fileSize) &#123;</span><br><span class="line">        if (checkFileCRCValid(m_actualSize, m_metaInfo-&gt;m_crcDigest)) &#123;</span><br><span class="line">            loadFromFile = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            checkLastConfirmedInfo();</span><br><span class="line"></span><br><span class="line">            if (!loadFromFile) &#123;</span><br><span class="line">                auto strategic = onMMKVCRCCheckFail(m_mmapID);</span><br><span class="line">                if (strategic == OnErrorRecover) &#123;</span><br><span class="line">                    loadFromFile = true;</span><br><span class="line">                    needFullWriteback = true;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">        checkLastConfirmedInfo();</span><br><span class="line"></span><br><span class="line">        if (!loadFromFile) &#123;</span><br><span class="line">            auto strategic = onMMKVFileLengthError(m_mmapID);</span><br><span class="line">            if (strategic == OnErrorRecover) &#123;</span><br><span class="line">                // make sure we don&#x27;t over read the file</span><br><span class="line">                m_actualSize = fileSize - Fixed32Size;</span><br><span class="line">                loadFromFile = true;</span><br><span class="line">                needFullWriteback = true;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>首先调用readActualSize尝试读取m_file中记录已经存储的数据长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">constexpr uint32_t LittleEdian32Size = 4;</span><br><span class="line"></span><br><span class="line">constexpr uint32_t pbFixed32Size() &#123;</span><br><span class="line">    return LittleEdian32Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constexpr uint32_t Fixed32Size = pbFixed32Size();</span><br><span class="line">size_t MMKV::readActualSize() &#123;</span><br><span class="line">    MMKV_ASSERT(m_file-&gt;getMemory());</span><br><span class="line">    MMKV_ASSERT(m_metaFile-&gt;isFileValid());</span><br><span class="line"></span><br><span class="line">    uint32_t actualSize = 0;</span><br><span class="line">    memcpy(&amp;actualSize, m_file-&gt;getMemory(), Fixed32Size);</span><br><span class="line"></span><br><span class="line">    if (m_metaInfo-&gt;m_version &gt;= MMKVVersionActualSize) &#123;</span><br><span class="line">        if (m_metaInfo-&gt;m_actualSize != actualSize) &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">        return m_metaInfo-&gt;m_actualSize;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return actualSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能看到首先从m_file获取映射的指针地址，往后读取4位数据。这4位数据就是actualSize 真实数据。但是如果是m_metaInfo的m_version 大于等于3，则获取m_metaInfo中保存的actualSize。</p>
</li>
<li><p>如果读取的到已经存储的数据小于映射内存的大小，或者读取已经读取的数据+4小于等于映射的内存大小，说明可以继续往里面存储不需要扩容。需要进一步的通过checkFileCRCValid校验里面的数据数据是否异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool MMKV::checkFileCRCValid(size_t actualSize, uint32_t crcDigest) &#123;</span><br><span class="line">    auto ptr = (uint8_t *) m_file-&gt;getMemory();</span><br><span class="line">    if (ptr) &#123;</span><br><span class="line">        m_crcDigest = (uint32_t) CRC32(0, (const uint8_t *) ptr + Fixed32Size, (uint32_t) actualSize);</span><br><span class="line"></span><br><span class="line">        if (m_crcDigest == crcDigest) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        MMKVError(&quot;check crc [%s] fail, crc32:%u, m_crcDigest:%u&quot;, m_mmapID.c_str(), crcDigest, m_crcDigest);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其校验的手段，是通过比较m_metaInfo保存的crcDigest和从m_file中读取的crcDigest进行比较，如果一致说明数据无误，则返回true，设置loadFromFile为true。</p>
</li>
<li><p>如果crc校验失败则会调用进行如下代码段进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> auto checkLastConfirmedInfo = [&amp;] &#123;</span><br><span class="line">        if (m_metaInfo-&gt;m_version &gt;= MMKVVersionActualSize) &#123;</span><br><span class="line">            // downgrade &amp; upgrade support</span><br><span class="line">            uint32_t oldStyleActualSize = 0;</span><br><span class="line">            memcpy(&amp;oldStyleActualSize, m_file-&gt;getMemory(), Fixed32Size);</span><br><span class="line">            if (oldStyleActualSize != m_actualSize) &#123;</span><br><span class="line">...</span><br><span class="line">                if (oldStyleActualSize &lt; fileSize &amp;&amp; (oldStyleActualSize + Fixed32Size) &lt;= fileSize) &#123;</span><br><span class="line">                    if (checkFileCRCValid(oldStyleActualSize, m_metaInfo-&gt;m_crcDigest)) &#123;</span><br><span class="line">...</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            auto lastActualSize = m_metaInfo-&gt;m_lastConfirmedMetaInfo.lastActualSize;</span><br><span class="line">            if (lastActualSize &lt; fileSize &amp;&amp; (lastActualSize + Fixed32Size) &lt;= fileSize) &#123;</span><br><span class="line">                auto lastCRCDigest = m_metaInfo-&gt;m_lastConfirmedMetaInfo.lastCRCDigest;</span><br><span class="line">                if (checkFileCRCValid(lastActualSize, lastCRCDigest)) &#123;</span><br><span class="line">                    loadFromFile = true;</span><br><span class="line">                    writeActualSize(lastActualSize, lastCRCDigest, nullptr, KeepSequence);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               ....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>其实这里面只处理m_metaInfo的m_version的状态大于等于3的状态。我们回忆一下，在readActualSize方法中，把读取当前存储的数据长度，分为两个逻辑进行读取。如果大于等于3，则从m_metaInfo中获取。</p>
</li>
</ol>
<p>crc校验失败，说明我们写入的时候发生异常。需要强制进行recover恢复数据。<br>首先要清除crc校验校验了什么东西：<br>1.可以检测出所有奇数位的错。<br>2.可以检测出双比特的错<br>3.可以检测出小于等于检测校验长度的突发错</p>
<p>MMKV做了如下处理，只处理状态等级在MMKVVersionActualSize情况。这个情况，在m_metaInfo记录上一次MMKV中的信息。因此可以通过m_metaInfo进行校验已经存储的数据长度，进而更新真实的已经记录数据的长度。</p>
<p>最后读取上一次MMKV还没有更新的备份数据长度和crc校验字段，通过writeActualSize记录在映射的内存中。</p>
<p>如果最后弥补的校验还是crc校验错误，最后会回调onMMKVCRCCheckFail这个方法。这个方法会反射Java层实现的异常处理策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (!loadFromFile) &#123;</span><br><span class="line">               auto strategic = onMMKVCRCCheckFail(m_mmapID);</span><br><span class="line">               if (strategic == OnErrorRecover) &#123;</span><br><span class="line">                   loadFromFile = true;</span><br><span class="line">                   needFullWriteback = true;</span><br><span class="line">               &#125;</span><br><span class="line">               MMKVInfo(&quot;recover strategic for [%s] is %d&quot;, m_mmapID.c_str(), strategic);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>如果是OnErrorRecover，则设置loadFromFile和needFullWriteback都为true，尽可能的恢复数据。当然如果OnErrorDiscard，则会丢弃掉所有的数据。</p>
<ol start="4">
<li>判断此时MMKV中预设的缓存已经满了，避免出现中间出现了上述的异常，也调用了一次checkLastConfirmedInfo进行状态的校验。发现loadFromFile确实为false，说明需要进行可能需要扩容：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (!loadFromFile) &#123;</span><br><span class="line">            auto strategic = onMMKVFileLengthError(m_mmapID);</span><br><span class="line">            if (strategic == OnErrorRecover) &#123;</span><br><span class="line">                m_actualSize = fileSize - Fixed32Size;</span><br><span class="line">                loadFromFile = true;</span><br><span class="line">                needFullWriteback = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
如果发现MMKV在外部进行初始化，异常处理策略是OnErrorRecover,尝试着扩容数据。则给loadFromFile和needFullWriteback都设置为true。m_actualSize为了避免覆盖掉了前面的长度记录，</li>
</ol>
<p>设置真实记录长度 &#x3D; 文件长度- 4</p>
<p>之后就以这个大小为基准进行扩容，在reloadFromFile方法中进行扩容。</p>
<h3><span id="mmkv第一次初始化或者读取文件失败">MMKV第一次初始化或者读取文件失败</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum : bool &#123;</span><br><span class="line">    KeepSequence = false,</span><br><span class="line">    IncreaseSequence = true,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            SCOPED_LOCK(m_exclusiveProcessLock);</span><br><span class="line"></span><br><span class="line">            m_output = new CodedOutputData(ptr + Fixed32Size, m_file-&gt;getFileSize() - Fixed32Size);</span><br><span class="line">            if (m_actualSize &gt; 0) &#123;</span><br><span class="line">                writeActualSize(0, 0, nullptr, IncreaseSequence);</span><br><span class="line">                sync(MMKV_SYNC);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                writeActualSize(0, 0, nullptr, KeepSequence);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>走到这个分支有两个条件，第一个是读取文件发现大小为0。第二个是读取文件出现了问题。第一个情况将会调用writeActualSize设置KeepSequence，第二个情况则设置IncreaseSequence。</p>
<p>其实writeActualSize这个方法就是往m_metaInfo记录相关于MMKV的信息。</p>
<h3><span id="writeactualsize">writeActualSize</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MMKV_WIN32</span><br><span class="line">#    ifndef likely</span><br><span class="line">#        define unlikely(x) (__builtin_expect(bool(x), 0))</span><br><span class="line">#        define likely(x) (__builtin_expect(bool(x), 1))</span><br><span class="line">#    endif</span><br><span class="line">#else</span><br></pre></td></tr></table></figure>
<p>注意if(unlikely(value))和if(likely(value)) 都等价于if(value)。唯一不同的是对编译器指令的优化。比如说这里的unlikely的意思是，判断到为假的可能性更大；相对的likely的意思是指，判断到真的可能性更大。</p>
<p>这样的话，编译器就能按照这个思路进行预先优化，将可能性更大的代码段接在判断的后面，减少跳转等指令的调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">bool MMKV::writeActualSize(size_t size, uint32_t crcDigest, const void *iv, bool increaseSequence) &#123;</span><br><span class="line">    // backward compatibility</span><br><span class="line">    oldStyleWriteActualSize(size);</span><br><span class="line"></span><br><span class="line">    if (!m_metaFile-&gt;isFileValid()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool needsFullWrite = false;</span><br><span class="line">    m_actualSize = size;</span><br><span class="line">    m_metaInfo-&gt;m_actualSize = static_cast&lt;uint32_t&gt;(size);</span><br><span class="line">    m_crcDigest = crcDigest;</span><br><span class="line">    m_metaInfo-&gt;m_crcDigest = crcDigest;</span><br><span class="line">    if (m_metaInfo-&gt;m_version &lt; MMKVVersionSequence) &#123;</span><br><span class="line">        m_metaInfo-&gt;m_version = MMKVVersionSequence;</span><br><span class="line">        needsFullWrite = true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (unlikely(iv)) &#123;</span><br><span class="line">        memcpy(m_metaInfo-&gt;m_vector, iv, sizeof(m_metaInfo-&gt;m_vector));</span><br><span class="line">        if (m_metaInfo-&gt;m_version &lt; MMKVVersionRandomIV) &#123;</span><br><span class="line">            m_metaInfo-&gt;m_version = MMKVVersionRandomIV;</span><br><span class="line">        &#125;</span><br><span class="line">        needsFullWrite = true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (unlikely(increaseSequence)) &#123;</span><br><span class="line">        m_metaInfo-&gt;m_sequence++;</span><br><span class="line">        m_metaInfo-&gt;m_lastConfirmedMetaInfo.lastActualSize = static_cast&lt;uint32_t&gt;(size);</span><br><span class="line">        m_metaInfo-&gt;m_lastConfirmedMetaInfo.lastCRCDigest = crcDigest;</span><br><span class="line">        if (m_metaInfo-&gt;m_version &lt; MMKVVersionActualSize) &#123;</span><br><span class="line">            m_metaInfo-&gt;m_version = MMKVVersionActualSize;</span><br><span class="line">        &#125;</span><br><span class="line">        needsFullWrite = true;</span><br><span class="line">    &#125;</span><br><span class="line">#ifdef MMKV_IOS</span><br><span class="line">...</span><br><span class="line">#else</span><br><span class="line">    if (unlikely(needsFullWrite)) &#123;</span><br><span class="line">        m_metaInfo-&gt;write(m_metaFile-&gt;getMemory());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        m_metaInfo-&gt;writeCRCAndActualSizeOnly(m_metaFile-&gt;getMemory());</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上文提到过的结构体MMKVMetaInfo其实就是在这里进行赋值。记录了m_actualSize以及crc校验的m_crcDigest。</p>
<p>如果是存储没有数据的话，m_actualSize为0，此时increaseSequence为false；存储过数据m_actualSize则大于0，increaseSequence为true。</p>
<ol>
<li><p>m_version默认是MMKVVersionSequence且iv为null。那么m_version将会设置为MMKVVersionRandomIV。一般来说这个iv的变化说明crc校验码发生了变化。</p>
</li>
<li><p>如果此时是IncreaseSequence为true，将会把当前的size和crc校验记录到m_lastConfirmedMetaInfo中，并且m_version升级成MMKVVersionActualSize。needsFullWrite都设置为true,m_sequence写回计数+1.</p>
</li>
<li><p>如果是第一次初始化，文件为空或者数据丢失，此时increaseSequence是KeepSequence为false，则不会记录相关写回的数据。</p>
</li>
<li><p>needsFullWrite为true,所以会走到writeCRCAndActualSizeOnly中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void writeCRCAndActualSizeOnly(void *ptr) &#123;</span><br><span class="line">        MMKV_ASSERT(ptr);</span><br><span class="line">        auto other = (MMKVMetaInfo *) ptr;</span><br><span class="line">        other-&gt;m_crcDigest = m_crcDigest;</span><br><span class="line">        other-&gt;m_actualSize = m_actualSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>能看到实际上就是把m_crcDigest和m_actualSize拷贝到m_metaFile内存文件映射的文件中。</p>
</li>
</ol>
<p>MMKV已经初始化过了，第二次打开与异常处理机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        if (loadFromFile &amp;&amp; m_actualSize &gt; 0) &#123;</span><br><span class="line">...</span><br><span class="line">            MMBuffer inputBuffer(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy);</span><br><span class="line">            if (m_crypter) &#123;</span><br><span class="line">                decryptBuffer(*m_crypter, inputBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">            clearDictionary(m_dic);</span><br><span class="line">            if (needFullWriteback) &#123;</span><br><span class="line">                MiniPBCoder::greedyDecodeMap(m_dic, inputBuffer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                MiniPBCoder::decodeMap(m_dic, inputBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">            m_output = new CodedOutputData(ptr + Fixed32Size, m_file-&gt;getFileSize() - Fixed32Size);</span><br><span class="line">            m_output-&gt;seek(m_actualSize);</span><br><span class="line">            if (needFullWriteback) &#123;</span><br><span class="line">                fullWriteback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一个类MMBuffer，这个类是MMKV的内存单元，里面保存了对应映射的指针，当然在iOS中就是一个NSData指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class MMBuffer &#123;</span><br><span class="line">private:</span><br><span class="line">    void *ptr;</span><br><span class="line">    size_t size;</span><br><span class="line">    MMBufferCopyFlag isNoCopy;</span><br><span class="line">#ifdef MMKV_APPLE</span><br><span class="line">    NSData *m_data = nil;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit MMBuffer(size_t length = 0);</span><br><span class="line">    MMBuffer(void *source, size_t length, MMBufferCopyFlag flag = MMBufferCopy);</span><br><span class="line">#ifdef MMKV_APPLE</span><br><span class="line">    explicit MMBuffer(NSData *data, MMBufferCopyFlag flag = MMBufferCopy);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    MMBuffer(MMBuffer &amp;&amp;other) noexcept;</span><br><span class="line">    MMBuffer &amp;operator=(MMBuffer &amp;&amp;other) noexcept;</span><br><span class="line"></span><br><span class="line">    ~MMBuffer();</span><br><span class="line"></span><br><span class="line">    void *getPtr() const &#123; return ptr; &#125;</span><br><span class="line"></span><br><span class="line">    size_t length() const &#123; return size; &#125;</span><br><span class="line"></span><br><span class="line">    // those are expensive, just forbid it for possibly misuse</span><br><span class="line">    explicit MMBuffer(const MMBuffer &amp;other) = delete;</span><br><span class="line">    MMBuffer &amp;operator=(const MMBuffer &amp;other) = delete;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一个是MiniPBCoder类，这个类实际上是用于解析Protocol Buffers的对象。这个对象是什么呢？其实可以和json进行类比。和json一样是一种对象序列化的手段。</p>
<ol>
<li><p>decryptBuffer解析inputBuffer中被AESCrypt加密的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void decryptBuffer(AESCrypt &amp;crypter, MMBuffer &amp;inputBuffer) &#123;</span><br><span class="line">    size_t length = inputBuffer.length();</span><br><span class="line">    MMBuffer tmp(length);</span><br><span class="line"></span><br><span class="line">    auto input = inputBuffer.getPtr();</span><br><span class="line">    auto output = tmp.getPtr();</span><br><span class="line">    crypter.decrypt(input, output, length);</span><br><span class="line"></span><br><span class="line">    inputBuffer = std::move(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AESCrypt::decrypt(const void *input, void *output, size_t length) &#123;</span><br><span class="line">    if (!input || !output || length == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    AES_cfb128_decrypt((const unsigned char *) input, (unsigned char *) output, length, m_aesKey, m_vector, &amp;m_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里面使用了OpenSSL 的AES CFB模式进行解析。解析后的数据指针将会指向inputBuffer。</p>
</li>
<li><p>needFullWriteback 不管是否为true都会把inputBuffer中的数据加载到全局散列表的m_dic中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void MiniPBCoder::decodeMap(MMKVMap &amp;dic, const MMBuffer &amp;oData, size_t size) &#123;</span><br><span class="line">    MiniPBCoder oCoder(&amp;oData);</span><br><span class="line">    oCoder.decodeOneMap(dic, size, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MiniPBCoder::greedyDecodeMap(MMKVMap &amp;dic, const MMBuffer &amp;oData, size_t size) &#123;</span><br><span class="line">    MiniPBCoder oCoder(&amp;oData);</span><br><span class="line">    oCoder.decodeOneMap(dic, size, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能发现其实所有的工作都会通过MiniPBCoder进行解析。在这里我就不对protbuf进行过多的解析，直接看MMKV的核心流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void MiniPBCoder::decodeOneMap(MMKVMap &amp;dic, size_t size, bool greedy) &#123;</span><br><span class="line">    auto block = [size, this](MMKVMap &amp;dictionary) &#123;</span><br><span class="line">        if (size == 0) &#123;</span><br><span class="line">            [[maybe_unused]] auto length = m_inputData-&gt;readInt32();</span><br><span class="line">        &#125;</span><br><span class="line">        while (!m_inputData-&gt;isAtEnd()) &#123;</span><br><span class="line">            const auto &amp;key = m_inputData-&gt;readString();</span><br><span class="line">            if (key.length() &gt; 0) &#123;</span><br><span class="line">                auto value = m_inputData-&gt;readData();</span><br><span class="line">                if (value.length() &gt; 0) &#123;</span><br><span class="line">                    dictionary[key] = move(value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dictionary.erase(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if (greedy) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            block(dic);</span><br><span class="line">        &#125; catch (std::exception &amp;exception) &#123;</span><br><span class="line">            MMKVError(&quot;%s&quot;, exception.what());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MMKVMap tmpDic;</span><br><span class="line">            block(tmpDic);</span><br><span class="line">            dic.swap(tmpDic);</span><br><span class="line">        &#125; catch (std::exception &amp;exception) &#123;</span><br><span class="line">            MMKVError(&quot;%s&quot;, exception.what());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上decodeOneMap的工作就是把保存在MiniPBCoder中的m_inputData进行解析，在这里就是指MMBuffer。把这些数据解析成一对对的键值对保存在MMKVMap这个m_dic散列表中。</p>
</li>
</ol>
<p>初始化的异常处理机制<br>而greedy的区别就是指是否直接把数据拷贝到m_dic中，不是则通过一个临时MMKVMap作为中转。我们稍微回忆一下。当MMKV尝试从MMKV缓存数据的文件进行加载时候失败或者内容已经满了，才会设置needFullWriteback为true。换句话说，设置异常处理OnErrorRecover这个标志位只有长度异常和crc校验不通过，且异常处理机制为尽可能的恢复。</p>
<p>那么解析这个地方就很简单了。<br>如果说此时needFullWriteback为false:如果MMKV在初始化数据是正常的，通过tmp进行swap中转的时候就会正常的设置到m_dic中。但是如果出现了错误，dic还没有从tmp交换容器内容就被异常抛出，m_dic将无法读取出数据。</p>
<p>如果说此时needFullWriteback为true：如果MMKV初始化异常，则因为没有swap直接通过block获取数据，就会尽可能的把缓存在磁盘的数据读取到内存中。</p>
<ol start="3">
<li><p>通过m_file的映射的内存生成CodedOutputData对象，并且调用seek方法跳到已经记录的数据末尾。<br>CodedOutputData的实例化可以看到此时是通过m_file往后移动4位之后开始拷贝到CodedOutputData中，其长度fileSize - 4位信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class CodedOutputData &#123;</span><br><span class="line">    uint8_t *const m_ptr;//内存指针</span><br><span class="line">    size_t m_size;//内存区域大小</span><br><span class="line">    size_t m_position;//读取到哪个位置</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void CodedOutputData::seek(size_t addedSize) &#123;</span><br><span class="line">    m_position += addedSize;</span><br><span class="line"></span><br><span class="line">    if (m_position &gt; m_size) &#123;</span><br><span class="line">        throw out_of_range(&quot;OutOfSpace&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>needFullWriteback如果为true则调用fullWriteback方法。说明此时出现了crc校验或者文件长度异常，同时异常处理机制为OnErrorRecover。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool MMKV::fullWriteback() &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    if (m_dic.empty()) &#123;</span><br><span class="line">        clearAll();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto allData = MiniPBCoder::encodeDataWithObject(m_dic);</span><br><span class="line">    SCOPED_LOCK(m_exclusiveProcessLock);</span><br><span class="line">    if (allData.length() &gt; 0) &#123;</span><br><span class="line">        auto fileSize = m_file-&gt;getFileSize();</span><br><span class="line">        if (allData.length() + Fixed32Size &lt;= fileSize) &#123;</span><br><span class="line">            return doFullWriteBack(std::move(allData));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            return ensureMemorySize(allData.length() + Fixed32Size - fileSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以分为如下几个步骤：</p>
</li>
<li><p>如果发现m_dic从磁盘缓存中读取PB数据是空的，则调用clearAll进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void MMKV::clearAll() &#123;</span><br><span class="line">    MMKVInfo(&quot;cleaning all key-values from [%s]&quot;, m_mmapID.c_str());</span><br><span class="line">    SCOPED_LOCK(m_lock);</span><br><span class="line">    SCOPED_LOCK(m_exclusiveProcessLock);</span><br><span class="line"></span><br><span class="line">    if (m_needLoadFromFile) &#123;</span><br><span class="line">        m_file-&gt;reloadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_file-&gt;truncate(DEFAULT_MMAP_SIZE);</span><br><span class="line">    auto ptr = m_file-&gt;getMemory();</span><br><span class="line">    if (ptr) &#123;</span><br><span class="line">        memset(ptr, 0, m_file-&gt;getFileSize());</span><br><span class="line">    &#125;</span><br><span class="line">    m_file-&gt;msync(MMKV_SYNC);</span><br><span class="line"></span><br><span class="line">    unsigned char newIV[AES_KEY_LEN];</span><br><span class="line">    AESCrypt::fillRandomIV(newIV);</span><br><span class="line">    if (m_crypter) &#123;</span><br><span class="line">        m_crypter-&gt;resetIV(newIV, sizeof(newIV));</span><br><span class="line">    &#125;</span><br><span class="line">    writeActualSize(0, 0, newIV, IncreaseSequence);</span><br><span class="line">    m_metaFile-&gt;msync(MMKV_SYNC);</span><br><span class="line"></span><br><span class="line">    clearMemoryCache();</span><br><span class="line">    loadFromFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发生这种情况说明我们就算想要强制恢复数据，发现从磁盘中读取PB数据根本没办法解析任何东西，可以认为这个文件已经完全损坏了，这个文件存在也没有意义，进行如下步骤的处理：</p>
</li>
</ol>
<p>调整m_file映射的大小。就会把file中映射的内存全部设置为0初始化，调用msync进行同步处理。</p>
<p>重新设置一个新的AESCrypt的key，设置到AESCrypt中，把这些数据通过writeActualSize写到meta_file中进行缓存。清空m_file映射数据后，重新通过loadFromFile初始化m_dic等数据。</p>
<ol start="2">
<li><p>如果发现m_dic调用encodeDataWithObject方法进行PB压缩加密为MMBuffer之后，发现MMBuffer比原来的文件内容要小，则调用doFullWriteBack把完好的数据通过doFullWriteBack写回到错误的文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool MMKV::doFullWriteBack(MMBuffer &amp;&amp;allData) &#123;</span><br><span class="line">    unsigned char newIV[AES_KEY_LEN];</span><br><span class="line">    if (m_crypter) &#123;</span><br><span class="line">        AESCrypt::fillRandomIV(newIV);</span><br><span class="line">        m_crypter-&gt;resetIV(newIV, sizeof(newIV));</span><br><span class="line">        auto ptr = allData.getPtr();</span><br><span class="line">        m_crypter-&gt;encrypt(ptr, ptr, allData.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto ptr = (uint8_t *) m_file-&gt;getMemory();</span><br><span class="line">    delete m_output;</span><br><span class="line">    m_output = new CodedOutputData(ptr + Fixed32Size, m_file-&gt;getFileSize() - Fixed32Size);</span><br><span class="line">    m_output-&gt;writeRawData(allData); // note: don&#x27;t write size of data</span><br><span class="line"></span><br><span class="line">    m_actualSize = allData.length();</span><br><span class="line">    if (m_crypter) &#123;</span><br><span class="line">        recaculateCRCDigestWithIV(newIV);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        recaculateCRCDigestWithIV(nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">    m_hasFullWriteback = true;</span><br><span class="line">    // make sure lastConfirmedMetaInfo is saved</span><br><span class="line">    sync(MMKV_SYNC);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑很简单，也是做了类似的处理。先经过AES加密后，把MMBuffer的数据通过CodedOutputData写入到m_file中，并更新crc的校验码。</p>
</li>
<li><p>如果发现encodeDataWithObject压缩后的大小比文件内容大，则会调用ensureMemorySize进行扩容，尝试着扩容成<br>尝试扩容的大小 &#x3D; 压缩后数据总大小 - 当前文件大小 - 4位长度标志位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">bool MMKV::ensureMemorySize(size_t newSize) &#123;</span><br><span class="line">....</span><br><span class="line">    // make some room for placeholder</span><br><span class="line">    constexpr size_t ItemSizeHolderSize = 4;</span><br><span class="line">    if (m_dic.empty()) &#123;</span><br><span class="line">        newSize += ItemSizeHolderSize;</span><br><span class="line">    &#125;</span><br><span class="line">    if (newSize &gt;= m_output-&gt;spaceLeft() || m_dic.empty()) &#123;</span><br><span class="line">        // try a full rewrite to make space</span><br><span class="line">        auto fileSize = m_file-&gt;getFileSize();</span><br><span class="line">        MMBuffer data = MiniPBCoder::encodeDataWithObject(m_dic);</span><br><span class="line">        size_t lenNeeded = data.length() + Fixed32Size + newSize;</span><br><span class="line">        size_t avgItemSize = lenNeeded / std::max&lt;size_t&gt;(1, m_dic.size());</span><br><span class="line">        size_t futureUsage = avgItemSize * std::max&lt;size_t&gt;(8, (m_dic.size() + 1) / 2);</span><br><span class="line">        // 1. no space for a full rewrite, double it</span><br><span class="line">        // 2. or space is not large enough for future usage, double it to avoid frequently full rewrite</span><br><span class="line">        if (lenNeeded &gt;= fileSize || (lenNeeded + futureUsage) &gt;= fileSize) &#123;</span><br><span class="line">            size_t oldSize = fileSize;</span><br><span class="line">            do &#123;</span><br><span class="line">                fileSize *= 2;</span><br><span class="line">            &#125; while (lenNeeded + futureUsage &gt;= fileSize);</span><br><span class="line"></span><br><span class="line">            if (!m_file-&gt;truncate(fileSize)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // check if we fail to make more space</span><br><span class="line">            if (!isFileValid()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return doFullWriteBack(std::move(data));</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的算法也很简单：</p>
</li>
<li><p>首先算出此时总共需要多少内存：</p>
<blockquote>
<p>总数据长度 &#x3D; 原数据长度+标志位+需要扩充大小</p>
</blockquote>
</li>
<li><p>计算平均m_dic中每一项平均占用大小：</p>
<blockquote>
<p>每一项内存平均大小 &#x3D; 总数据长度 &#x2F; max(1,m_dic 的项数)</p>
</blockquote>
</li>
<li><p>futureUsage 扩充的额外容量，减少map的hash散列冲突，相当于扩充了1.5倍</p>
<blockquote>
<p>扩充的额外容量 &#x3D; 每一项内存平均大小 * max(8 , (m_dic的项数+1)&#x2F;2)</p>
</blockquote>
</li>
<li><p>不断的把原来的file大小扩容2倍，直到比扩充的额外容量的大小要大为止，最后通过truncate，把大小变成4kb的倍数。</p>
</li>
<li><p>doFullWriteBack 写回m_file中记录数据。</p>
</li>
</ol>
<p>到这里MMKV的初始化和错误校验和恢复流程的处理就结束了，我们来看看MMKV是如何读写的。</p>
<h3><span id="mmkv-encode-写入数据">MMKV encode 写入数据</span></h3><p>这里以常见的encodeString为例子。<br>根据上面注册的native 方法，我们可以知道对应如下的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static string jstring2string(JNIEnv *env, jstring str) &#123;</span><br><span class="line">    if (str) &#123;</span><br><span class="line">        const char *kstr = env-&gt;GetStringUTFChars(str, nullptr);</span><br><span class="line">        if (kstr) &#123;</span><br><span class="line">            string result(kstr);</span><br><span class="line">            env-&gt;ReleaseStringUTFChars(str, kstr);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MMKV_JNI jboolean encodeString(JNIEnv *env, jobject, jlong handle, jstring oKey, jstring oValue) &#123;</span><br><span class="line">    MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle);</span><br><span class="line">    if (kv &amp;&amp; oKey) &#123;</span><br><span class="line">        string key = jstring2string(env, oKey);</span><br><span class="line">        if (oValue) &#123;</span><br><span class="line">            string value = jstring2string(env, oValue);</span><br><span class="line">            return (jboolean) kv-&gt;set(value, key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            kv-&gt;removeValueForKey(key);</span><br><span class="line">            return (jboolean) true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (jboolean) false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能看到在这里面本质上就是调用了MMKV的set方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool MMKV::set(const string &amp;value, MMKVKey_t key) &#123;</span><br><span class="line">    if (isKeyEmpty(key)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    auto data = MiniPBCoder::encodeDataWithObject(value);</span><br><span class="line">    return setDataForKey(std::move(data), key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里做了两件事情：</p>
<ol>
<li>encodeDataWithObject 编码压缩内容</li>
<li>setDataForKey 保存数据</li>
</ol>
<h4><span id="encodedatawithobject-编码压缩内容">encodeDataWithObject 编码压缩内容</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static MMBuffer encodeDataWithObject(const T &amp;obj) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MiniPBCoder pbcoder;</span><br><span class="line">            return pbcoder.getEncodeData(obj);</span><br><span class="line">        &#125; catch (const std::exception &amp;exception) &#123;</span><br><span class="line">            MMKVError(&quot;%s&quot;, exception.what());</span><br><span class="line">            return MMBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">MMBuffer MiniPBCoder::getEncodeData(const string &amp;str) &#123;</span><br><span class="line">    m_encodeItems = new vector&lt;PBEncodeItem&gt;();</span><br><span class="line">    size_t index = prepareObjectForEncode(str);</span><br><span class="line">    PBEncodeItem *oItem = (index &lt; m_encodeItems-&gt;size()) ? &amp;(*m_encodeItems)[index] : nullptr;</span><br><span class="line">    if (oItem &amp;&amp; oItem-&gt;compiledSize &gt; 0) &#123;</span><br><span class="line">        m_outputBuffer = new MMBuffer(oItem-&gt;compiledSize);</span><br><span class="line">        m_outputData = new CodedOutputData(m_outputBuffer-&gt;getPtr(), m_outputBuffer-&gt;length());</span><br><span class="line"></span><br><span class="line">        writeRootObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return move(*m_outputBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>prepareObjectForEncode 这个方法会解析当前的数据，设置相关的编码准备数据。</li>
<li>根据prepareObjectForEncode的index获取对应的PBEncodeItem对象，通过writeRootObject把数据保存到MMBuffer 临时开辟的缓存中。</li>
</ol>
<h4><span id="prepareobjectforencode">prepareObjectForEncode</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">size_t MiniPBCoder::prepareObjectForEncode(const string &amp;str) &#123;</span><br><span class="line">    m_encodeItems-&gt;push_back(PBEncodeItem());</span><br><span class="line">    PBEncodeItem *encodeItem = &amp;(m_encodeItems-&gt;back());</span><br><span class="line">    size_t index = m_encodeItems-&gt;size() - 1;</span><br><span class="line">    &#123;</span><br><span class="line">        encodeItem-&gt;type = PBEncodeItemType_String;</span><br><span class="line">        encodeItem-&gt;value.strValue = &amp;str;</span><br><span class="line">        encodeItem-&gt;valueSize = static_cast&lt;int32_t&gt;(str.size());</span><br><span class="line">    &#125;</span><br><span class="line">    encodeItem-&gt;compiledSize = pbRawVarint32Size(encodeItem-&gt;valueSize) + encodeItem-&gt;valueSize;</span><br><span class="line"></span><br><span class="line">    return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能看到在这个过程中会把PBEncodeItem缓存到m_encodeItems这个vector集合中。并且设置encodeItem的类型为String，保存string内容，以及字符串大小。最后设置compiledSize记录编码后的大小，这个大小包含了标志位的大小，因此会比原来的大。</p>
<h4><span id="writerootobject">writeRootObject</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void MiniPBCoder::writeRootObject() &#123;</span><br><span class="line">    for (size_t index = 0, total = m_encodeItems-&gt;size(); index &lt; total; index++) &#123;</span><br><span class="line">        PBEncodeItem *encodeItem = &amp;(*m_encodeItems)[index];</span><br><span class="line">        switch (encodeItem-&gt;type) &#123;</span><br><span class="line">            case PBEncodeItemType_Data: &#123;</span><br><span class="line">                m_outputData-&gt;writeData(*(encodeItem-&gt;value.bufferValue));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case PBEncodeItemType_Container: &#123;</span><br><span class="line">                m_outputData-&gt;writeUInt32(encodeItem-&gt;valueSize);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case PBEncodeItemType_String: &#123;</span><br><span class="line">                m_outputData-&gt;writeString(*(encodeItem-&gt;value.strValue));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            case PBEncodeItemType_None: &#123;</span><br><span class="line">                MMKVError(&quot;%d&quot;, encodeItem-&gt;type);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实际上是调用了CodedOutputData的writeString把数据保存到映射的内存中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void CodedOutputData::writeString(const string &amp;value) &#123;</span><br><span class="line">    size_t numberOfBytes = value.size();</span><br><span class="line">    this-&gt;writeRawVarint32((int32_t) numberOfBytes);</span><br><span class="line">    if (m_position + numberOfBytes &gt; m_size) &#123;</span><br><span class="line">        auto msg = &quot;m_position: &quot; + to_string(m_position) + &quot;, numberOfBytes: &quot; + to_string(numberOfBytes) +</span><br><span class="line">                   &quot;, m_size: &quot; + to_string(m_size);</span><br><span class="line">        throw out_of_range(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(m_ptr + m_position, ((uint8_t *) value.data()), numberOfBytes);</span><br><span class="line">    m_position += numberOfBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能看到实际上十分简单，就是把数据直接拷贝MMBuffer的临时缓冲区中。并且把存储的位置向后移动存储的长度。并通过m_position保存起来，下一次就从这里开始保存。</p>
<p>最后把这个临时缓冲区MMBuffer返回。</p>
<h4><span id="setdataforkey-保存数据到映射的文件">setDataForKey 保存数据到映射的文件</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool MMKV::setDataForKey(MMBuffer &amp;&amp;data, MMKVKey_t key) &#123;</span><br><span class="line">    if (data.length() == 0 || isKeyEmpty(key)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPED_LOCK(m_lock);</span><br><span class="line">    SCOPED_LOCK(m_exclusiveProcessLock);</span><br><span class="line">    checkLoadData();</span><br><span class="line"></span><br><span class="line">    auto ret = appendDataWithKey(data, key);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        m_dic[key] = std::move(data);</span><br><span class="line">        m_hasFullWriteback = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为需要开始写入数据了，这里设置了互斥锁，和线程锁。整个步骤分为两步骤：</p>
<ol>
<li>checkLoadData 保存数据之前，校验已经存储的数据</li>
<li>appendDataWithKey 进行数据的保存</li>
</ol>
<h4><span id="checkloaddata">checkLoadData</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void MMKV::checkLoadData() &#123;</span><br><span class="line"> ...</span><br><span class="line">    // TODO: atomic lock m_metaFile?</span><br><span class="line">    MMKVMetaInfo metaInfo;</span><br><span class="line">    metaInfo.read(m_metaFile-&gt;getMemory());</span><br><span class="line">    if (m_metaInfo-&gt;m_sequence != metaInfo.m_sequence) &#123;</span><br><span class="line"></span><br><span class="line">        SCOPED_LOCK(m_sharedProcessLock);</span><br><span class="line"></span><br><span class="line">        clearMemoryCache();</span><br><span class="line">        loadFromFile();</span><br><span class="line">        notifyContentChanged();</span><br><span class="line">    &#125; else if (m_metaInfo-&gt;m_crcDigest != metaInfo.m_crcDigest) &#123;</span><br><span class="line"></span><br><span class="line">        SCOPED_LOCK(m_sharedProcessLock);</span><br><span class="line"></span><br><span class="line">        size_t fileSize = m_file-&gt;getActualFileSize();</span><br><span class="line">        if (m_file-&gt;getFileSize() != fileSize) &#123;</span><br><span class="line">            clearMemoryCache();</span><br><span class="line">            loadFromFile();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            partialLoadFromFile();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果发现记录在m_metaFile中的m_sequence和缓存在内存中的m_sequence不一致。说明这个过程中发生过writeActualSize的调用。而这个方法的调用一般是文件读取发生了异常，要么是长度不足，要么是crc校验过不去。此时会进行一次初始化异常处理，因此重新读取一次m_file进行初始化。记住MMKV是支持多进程的，需要不断的校验内存文件是否被另一个进程给写坏了。</p>
</li>
<li><p>crc发现了变动，说明文件可能进行了扩容，扩容了可能会进行内存重排(重新绑定了mmap)，因此需要重新读取数据。</p>
</li>
</ol>
<p>如果相等说明文件没有扩容，但是因为内存触顶，重新设置MMKV的加密key，而触发了fullWriteback 完全写回，导致文件可能更新了crc校验码。这个过程将会调用partialLoadFromFile从内存文件中更新crc校验码，缓存的数据，数据写入位置到内存中。</p>
<h4><span id="appenddatawithkey">appendDataWithKey</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bool MMKV::appendDataWithKey(const MMBuffer &amp;data, MMKVKey_t key) &#123;</span><br><span class="line"></span><br><span class="line">    size_t keyLength = key.length();</span><br><span class="line">    // size needed to encode the key</span><br><span class="line">    size_t size = keyLength + pbRawVarint32Size((int32_t) keyLength);</span><br><span class="line">    // size needed to encode the value</span><br><span class="line">    size += data.length() + pbRawVarint32Size((int32_t) data.length());</span><br><span class="line"></span><br><span class="line">    SCOPED_LOCK(m_exclusiveProcessLock);</span><br><span class="line"></span><br><span class="line">    bool hasEnoughSize = ensureMemorySize(size);</span><br><span class="line">    if (!hasEnoughSize || !isFileValid()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_output-&gt;writeString(key);</span><br><span class="line"></span><br><span class="line">    m_output-&gt;writeData(data); // note: write size of data</span><br><span class="line"></span><br><span class="line">    auto ptr = (uint8_t *) m_file-&gt;getMemory() + Fixed32Size + m_actualSize;</span><br><span class="line">    if (m_crypter) &#123;</span><br><span class="line">        m_crypter-&gt;encrypt(ptr, ptr, size);</span><br><span class="line">    &#125;</span><br><span class="line">    m_actualSize += size;</span><br><span class="line">    updateCRCDigest(ptr, size);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程就很简单了，判断是否有足够的空间，没有则调用ensureMemorySize进行扩容，实在无法从内存中映射出来，那说明系统没空间了就返回异常。</p>
<p>正常情况下，是往全局缓冲区CodedOutputData 先后在文件内存的末尾写入key和value的数据。并对这部分的数据进行一次加密，最后更新这个存储区域的crc校验码。</p>
<h4><span id="decode-mmkv读取数据">decode MMKV读取数据</span></h4><p>接下来关注MMKV是如何读取数据的。还是以String为例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">MMKV_JNI jstring decodeString(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jstring oDefaultValue) &#123;</span><br><span class="line">    MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle);</span><br><span class="line">    if (kv &amp;&amp; oKey) &#123;</span><br><span class="line">        string key = jstring2string(env, oKey);</span><br><span class="line">        string value;</span><br><span class="line">        bool hasValue = kv-&gt;getString(key, value);</span><br><span class="line">        if (hasValue) &#123;</span><br><span class="line">            return string2jstring(env, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return oDefaultValue;</span><br><span class="line">&#125;</span><br><span class="line">bool MMKV::getString(MMKVKey_t key, string &amp;result) &#123;</span><br><span class="line">    if (isKeyEmpty(key)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPED_LOCK(m_lock);</span><br><span class="line">    auto &amp;data = getDataForKey(key);</span><br><span class="line">    if (data.length() &gt; 0) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            result = MiniPBCoder::decodeString(data);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (std::exception &amp;exception) &#123;</span><br><span class="line">            MMKVError(&quot;%s&quot;, exception.what());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致可以分分为两步：</p>
<ol>
<li>getDataForKey 通过key找缓存的数据</li>
<li>decodeString 对获取到的数据进行解码</li>
</ol>
<h4><span id="getdataforkey">getDataForKey</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const MMBuffer &amp;MMKV::getDataForKey(MMKVKey_t key) &#123;</span><br><span class="line">    checkLoadData();</span><br><span class="line">    auto itr = m_dic.find(key);</span><br><span class="line">    if (itr != m_dic.end()) &#123;</span><br><span class="line">        return itr-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    static MMBuffer nan;</span><br><span class="line">    return nan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是一个多进程的组件，因此每一次进行读写之前都需要进行一次checkLoadData的校验。而这个方法从上文可知，通过crc校验码，写回计数，文件长度来判断文件是否发生了变更，是否追加删除数据，从而是否需要重新充内存文件中获取数据缓存到m_dic。</p>
<p>也因此，在getDataForKey方法中，可以直接从m_dic中通过key找value。</p>
<h4><span id="decodestring">decodeString</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">string MiniPBCoder::decodeString(const MMBuffer &amp;oData) &#123;</span><br><span class="line">    MiniPBCoder oCoder(&amp;oData);</span><br><span class="line">    return oCoder.decodeOneString();</span><br><span class="line">&#125;</span><br><span class="line">string MiniPBCoder::decodeOneString() &#123;</span><br><span class="line">    return m_inputData-&gt;readString();</span><br><span class="line">&#125;</span><br><span class="line">string CodedInputData::readString() &#123;</span><br><span class="line">    int32_t size = readRawVarint32();</span><br><span class="line">    if (size &lt; 0) &#123;</span><br><span class="line">        throw length_error(&quot;InvalidProtocolBuffer negativeSize&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto s_size = static_cast&lt;size_t&gt;(size);</span><br><span class="line">    if (s_size &lt;= m_size - m_position) &#123;</span><br><span class="line">        string result((char *) (m_ptr + m_position), s_size);</span><br><span class="line">        m_position += s_size;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw out_of_range(&quot;InvalidProtocolBuffer truncatedMessage&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能看到实际上很简单就是从m_dic找到对应的MMBuffer数据，此时的可以通过CodedInputData对MMBuffer对应的内存块(已经知道内存起始地址，长度)进行解析数据。</p>
<h4><span id="mmkv-初始化读写的小结">MMKV 初始化读写的小结</span></h4><p>当然可能有人觉得奇怪，当时encode不是已经加密了一个键值对的数据块了吗？为什么在读取时候没有进行AES的解析呢？这里就要说一下AES加密解密都是以128位为一个单位进行加解密。当我们调用loadFromFile方法的时候，在更新m_dic方法就会对整个缓存文件数据进行解密。怎么保证整个文件大小是16位的倍数呢？调用encrypt 也就是AES_cfb128_encrypt的加密时候就会进行一次保险的数据填充。</p>
<p>同理crc校验码实际上并非是对整个内存文件的数据进行一次校对，而实际上是对上一次存储的内存进行一次crc校对。如果上一次存储的内容crc校验码正常，则说明整个MMKV的读写是正确的。</p>
<p>那么我们可以理解MMKVMetaInfo中的m_lastConfirmedMetaInfo结构体的意思了。因为保证了每一次读写的正确性，因此如果想要恢复，只需要通过m_lastConfirmedMetaInfo记录最近一次读写的状态，对meta_file进行恢复即可达到原来的MMKV应有的配置。</p>
<h2><span id="mmkv-进程锁设计">MMKV 进程锁设计</span></h2><p>MMKV作为一个多进程组件，其多进程如何进行同步也是值得我们学习的。重新回顾一下，进程的文件锁有几种操作方式：</p>
<ol>
<li>LOCK_EX 排他锁 定义的代码范围中只允许一个进程操作</li>
<li>LOCK_SH 共享锁 定义的代码范围中允许多个进程操作</li>
<li>LOCK_UN 释放锁 释放锁定的区域<br>其实在早两年前，我写过一章关于线程的设计与思考。其中有聊到过读写锁。其实对于一个文件还是内存读写而言，最害怕的是读取出来的信息有误。有什么方法避免呢？其实就可以通过读写锁的设计进行避免。当写的时候只允许一个进程或者线程，这样就能保证文件或者内存中的内容不变。这样读取数据的时候也没有必要进行加锁处理。这种思路在进程锁也是同理。</li>
</ol>
<p>所以在MMKV中用排他锁作为写锁，用共享锁作为读锁。</p>
<p>这是一个很简单且通用的思想。但是MMKV选择自己实现了一个文件锁？而不是直接使用Linux系统提供的api flock，这是为什么呢？这就是大神和普通程序员的区别了。</p>
<p>他们除了考虑了单一锁的情况，还考虑更加特殊常见的锁加完再加锁的递归锁问题以及锁的升降级。文件锁不支持锁的升降级。如果支持锁的升级，容易发生死锁。</p>
<p>死锁发生的四个条件：</p>
<ol>
<li>互斥条件： 一段时间内资源只允许一个任务持有</li>
<li>不可剥夺条件： 任务所获的的资源只能由自己释放</li>
<li>请求与保持条件：任务已经持有了一个资源，但是又提出了新的资源请求，而该资源被另一个任务持有，此时请求的行为被阻塞，不释放自己的资源</li>
<li>循环等待 若干任务形成首尾相接的循环等待资源</li>
</ol>
<p>死锁产生的两个原因:</p>
<ol>
<li>系统资源的竞争</li>
<li>任务运行的推进顺序顺序不当</li>
</ol>
<p>注:这里的任务特指进程或者线程</p>
<p>在这个过程中，如果2个进程中持有了读锁，都想升级为写锁，就可能被阻塞进入到死锁状态。其次文件锁也不支持锁的降级，一旦解开了就消失了。</p>
<p>可以在MMKV的构造函数中，知道有两种进程锁会存在其中。一个是排他锁，一个是共享锁。他们的类型都是InterProcessLock。InterProcessLock其中的核心就是FileLock文件锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class InterProcessLock &#123;</span><br><span class="line">    FileLock *m_fileLock;</span><br><span class="line">    LockType m_lockType;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    InterProcessLock(FileLock *fileLock, LockType lockType)</span><br><span class="line">        : m_fileLock(fileLock), m_lockType(lockType), m_enable(true) &#123;</span><br><span class="line">        MMKV_ASSERT(m_fileLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool m_enable;</span><br><span class="line"></span><br><span class="line">    void lock() &#123;</span><br><span class="line">        if (m_enable) &#123;</span><br><span class="line">            m_fileLock-&gt;lock(m_lockType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool try_lock() &#123;</span><br><span class="line">        if (m_enable) &#123;</span><br><span class="line">            return m_fileLock-&gt;try_lock(m_lockType);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unlock() &#123;</span><br><span class="line">        if (m_enable) &#123;</span><br><span class="line">            m_fileLock-&gt;unlock(m_lockType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里面对应MMKV Java的native api有三个，lock，unlock，try_lock。分别是上锁，解锁，尝试上锁。我们先来看看上锁逻辑</p>
<h3><span id="mmkv-文件锁上锁">MMKV 文件锁上锁</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool FileLock::lock(LockType lockType) &#123;</span><br><span class="line">    return doLock(lockType, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool FileLock::try_lock(LockType lockType) &#123;</span><br><span class="line">    return doLock(lockType, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能看到本质上就是一个都是调用doLock方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bool FileLock::doLock(LockType lockType, bool wait) &#123;</span><br><span class="line">    if (!isFileLockValid()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool unLockFirstIfNeeded = false;</span><br><span class="line"></span><br><span class="line">    if (lockType == SharedLockType) &#123;</span><br><span class="line">        // don&#x27;t want shared-lock to break any existing locks</span><br><span class="line">        if (m_sharedLockCount &gt; 0 || m_exclusiveLockCount &gt; 0) &#123;</span><br><span class="line">            m_sharedLockCount++;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // don&#x27;t want exclusive-lock to break existing exclusive-locks</span><br><span class="line">        if (m_exclusiveLockCount &gt; 0) &#123;</span><br><span class="line">            m_exclusiveLockCount++;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // prevent deadlock</span><br><span class="line">        if (m_sharedLockCount &gt; 0) &#123;</span><br><span class="line">            unLockFirstIfNeeded = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto ret = platformLock(lockType, wait, unLockFirstIfNeeded);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        if (lockType == SharedLockType) &#123;</span><br><span class="line">            m_sharedLockCount++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            m_exclusiveLockCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果是共享锁想要加锁，判断到已经有共享锁或者排他锁已经在本进程已经添加了，此时共享锁直接返回true，不需要真的调用lock方法。</li>
<li>排斥锁类型想要加锁，如果发现已经加了排他锁(m_exclusiveLockCount 排他锁计数)，则直接返回。如果m_sharedLockCount 共享锁加锁计数大于0则设置unLockFirstIfNeeded为true(防止死锁)。<br>换句话说，如果是共享锁想要加锁，只有m_sharedLockCount和m_exclusiveLockCount计数都为0，才会真的走到platformLock执行。</li>
</ol>
<p>如果排他锁想要加锁，只有m_exclusiveLockCount 排他锁计数为0才会执行platformLock。</p>
<p>只有platformLock 执行成功了，才会给对应类型锁的对应计数+1.</p>
<h3><span id="platformlock">platformLock</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static int32_t LockType2FlockType(LockType lockType) &#123;</span><br><span class="line">    switch (lockType) &#123;</span><br><span class="line">        case SharedLockType:</span><br><span class="line">            return LOCK_SH;</span><br><span class="line">        case ExclusiveLockType:</span><br><span class="line">            return LOCK_EX;</span><br><span class="line">    &#125;</span><br><span class="line">    return LOCK_EX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool FileLock::platformLock(LockType lockType, bool wait, bool unLockFirstIfNeeded) &#123;</span><br><span class="line">#    ifdef MMKV_ANDROID</span><br><span class="line">    if (m_isAshmem) &#123;</span><br><span class="line">        return ashmemLock(lockType, wait, unLockFirstIfNeeded);</span><br><span class="line">    &#125;</span><br><span class="line">#    endif</span><br><span class="line">    auto realLockType = LockType2FlockType(lockType);</span><br><span class="line">    auto cmd = wait ? realLockType : (realLockType | LOCK_NB);</span><br><span class="line">    if (unLockFirstIfNeeded) &#123;</span><br><span class="line">        // try lock</span><br><span class="line">        auto ret = flock(m_fd, realLockType | LOCK_NB);</span><br><span class="line">        if (ret == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // let&#x27;s be gentleman: unlock my shared-lock to prevent deadlock</span><br><span class="line">        ret = flock(m_fd, LOCK_UN);</span><br><span class="line">        if (ret != 0) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto ret = flock(m_fd, cmd);</span><br><span class="line">    if (ret != 0) &#123;</span><br><span class="line">...</span><br><span class="line">        // try recover my shared-lock</span><br><span class="line">        if (unLockFirstIfNeeded) &#123;</span><br><span class="line">            ret = flock(m_fd, LockType2FlockType(SharedLockType));</span><br><span class="line">            if (ret != 0) &#123;</span><br><span class="line">                // let&#x27;s hope this never happen</span><br><span class="line">....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果发现锁是Ashmem匿名内存的锁，则调用ashmemLock处理</li>
<li>unLockFirstIfNeeded 这个标志位只有在排他锁(写锁)想要上锁的时候，发现有共享锁(读锁)已经上锁了才为true。则会尝试进行进行排他锁(写锁)的阻塞的上锁等待，一旦失败，则解开共享锁(读锁)，在加上排他锁(写锁)。这样能避免2个读锁同时存在，另一个进程也想升级成排他锁(写锁)。</li>
<li>其他情况则根据wait标志位来决定是否需要进行阻塞,这就是tryLock和lock的区别，tryLock不会阻塞。</li>
<li>最后如果此时已经有读锁，想上写锁的情况下，则会把写锁降级为读锁并返回false。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/android/" rel="tag"># android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/02/github%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E8%B4%A6%E5%8F%B7/" rel="prev" title="github部署多个账号">
      <i class="fa fa-chevron-left"></i> github部署多个账号
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/28/http%E8%AE%A4%E7%9F%A5/" rel="next" title="http认知">
      http认知 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">SharedPreferences缺点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">mmkv</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.1.</span> <span class="nav-text">简单介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.2.</span> <span class="nav-text">具体用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.1.</span> <span class="nav-text">入键值对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.2.</span> <span class="nav-text">读取键值对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.3.</span> <span class="nav-text">删除和查键值对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.4.</span> <span class="nav-text">其他用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.5.</span> <span class="nav-text">多进程缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.6.</span> <span class="nav-text">Ashmem匿名内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.7.</span> <span class="nav-text">MMKV迁移到SharePrefences</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">mmkv源码介些</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.1.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.1.1.</span> <span class="nav-text">Java初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">MMKV native层的初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.1.2.</span> <span class="nav-text">MMKV jniInitialize</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.2.</span> <span class="nav-text">MMKV 的实例化 defaultMMKV与mmkvWithID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.3.</span> <span class="nav-text">MMKV 的构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.4.</span> <span class="nav-text">MemoryFile的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.5.</span> <span class="nav-text">MMKV的初始化 loadFromFile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.5.1.</span> <span class="nav-text">checkDataValid 校验MMKV数据有效性机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.5.2.</span> <span class="nav-text">MMKV第一次初始化或者读取文件失败</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.5.3.</span> <span class="nav-text">writeActualSize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.5.4.</span> <span class="nav-text">MMKV encode 写入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.4.1.</span> <span class="nav-text">encodeDataWithObject 编码压缩内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.4.2.</span> <span class="nav-text">prepareObjectForEncode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.4.3.</span> <span class="nav-text">writeRootObject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.4.4.</span> <span class="nav-text">setDataForKey 保存数据到映射的文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.4.5.</span> <span class="nav-text">checkLoadData</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.4.6.</span> <span class="nav-text">appendDataWithKey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.4.7.</span> <span class="nav-text">decode MMKV读取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.4.8.</span> <span class="nav-text">getDataForKey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.4.9.</span> <span class="nav-text">decodeString</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.4.10.</span> <span class="nav-text">MMKV 初始化读写的小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.6.</span> <span class="nav-text">MMKV 进程锁设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.6.1.</span> <span class="nav-text">MMKV 文件锁上锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.6.2.</span> <span class="nav-text">platformLock</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="pacoblack"
      src="/images/avatar1.jpeg">
  <p class="site-author-name" itemprop="name">pacoblack</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/pacoblack" title="GitHub → https://github.com/pacoblack" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:pacoson.wang@gmail.com" title="E-Mail → mailto:pacoson.wang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pacoblack</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='99' src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css" class="aplayer-style-marker">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js" class="aplayer-script-marker"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js" class="meting-script-marker"></script>
  <div id="aplayer-AXqIDvNX"
      class="aplayer aplayer-tag-marker meting-tag-marker aplayer-fixed"
      data-id="71075946"
      data-server="netease"
      data-type="playlist"
      data-mode="circulation"
      data-autoplay="false"
      data-mutex="true"
      data-listmaxheight="340px"
      data-preload="auto"
      data-fixed="true"
      data-lrctype="0"
      data-theme="#555"></div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body>
</html>
